### USER
I want to build a javascript library, packaged so that I can add it to a GitHub repo and use it via jsDeliver. The package should have a function that accepts a CITE2 URN as a parameter identifying an image from the Homer Multitext project (HMT) available through the IIIF protocol, and then supports three separate modes of interaction with the image. Here's the information you need to define IIIF requests for the Homer Muiltitext project.
Protocol: http
Server: www.homermultitext.org/iipsrv?IIIF=
Prefix: The information we need to construct the correct prefix is included in the image identifier. Images are identified with CITE2 URN, which have 5 components separated by colons. The IIIF prefix for the HMT server is constructed from a base path `/project/homer/pyramidal/deepzoom`, to which we append three further elements, joining each with a slash `/`. The first piece we append is the URN's namespace, the third colon-delimited component of the URN; the second and third pieces we append are taken from the collection component, which is the fourth colon-delimited part of the URN. This component has two parts separated by a period: we append each of these separately.
Image: images in the HMT service are in TIF format. To form the correct image identify, append `.tif` to the object identifier (final component of the CITE2 URN.)
Here's a complete example: for the CITE2 URN `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`, the namespace is `hmt` (third component); the workspace component is `vaimg.2017a` (fourth component); the object identifier is `VA012RN_0013`. We form the IIIF prefix by joinging to the base path `/project/homer/pyramidal/deepzoom` the namespace value, and two period-separted parts of the collection value. The full IIIF prefix is therefore `/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a`. We form the image identifier by appending `.tif` to the objectcompnonent and get `VA012RN_0013.tif`. A complete `info` request for this image on the HMT IIIF service would therefore be `http://www.homermultitext.org/iipsrv?IIIF=/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a/VA012RN_0013.tif/info.json`
Here are the three
1.  The first mode is a standard image viewer that allows the user to zoom and pan the image. The design should support including multiple instances of a viewer on a single web page, with each viewer supporting panning and zooming of the image it was constructed with. The IIIF viewer should be built from scratch rather than using a library like OpenSeaDragon. Use anonymous CORS to avoid restrictions on cross-origin access.
    
2.  The second mode is a rectangle selection mode, which is activated when the user holds down the option key and clicks and drags on the image. In this mode, the user can draw a rectangle on the image, and the coordinates of the rectangle are returned to a listener function. The coordinates should be formatted as an x,y pair expressed as percentages from 0 to 1, and appended to the URN for the example. The return value should be a list of these URNs separated by newline characters, so that the user can draw multiple rectangles and get a single string of coordinates back. The user should be able to draw multiple rectangles, and the coordinates of each rectangle should be returned in a single multiline string, one URN per line.
    
3.  The third mode is a query mode, which is activated when the user holds down the shift key and clicks on the image. In this mode, the image viewer should check to see if the point that the user has clicked is within the bounds of any of the highlighted rectangles. Note that since rectangles could overlap, the point could lie within zero, one or more rectangles. A list of the rectangles should be passed to a listener function. If the point lies within zero rectangles, an empty list should be passed to the listener function. The rectangles should be identified as image URNs with ROI extension, i.e. @x,y,w,h where x,y,w,h are all expressed as percentages from 0 to 1, and appended to the basic URN for the image.
    
To test the library, please also write two HTML files. One should test displaying two images with the URNs `urn:cite2:hmt:vaimg.2017a:VA012RN_0013` and `urn:cite2:hmt:vaimg.2017a:VA013RN_0014`. The second HTML file should test the rectangle selection and query modes. Allow the user to enter a URN (default: `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`), and display a list of highlighted retangles if any. Update the list when the user adds a new rectangle by option-clicking. When the user shift-clicks, display a message with the URN of any rectangles that contain the clicked point. Note that since rectangles could overlap, the point could lie within zero, one or more rectangles. A list of the rectangles should be passed to a listener function. If the point lies within zero rectangles, an empty list should be passed to the listener function. The rectangles should be identified as image URNs with ROI extension, i.e. @x,y,w,h where x,y,w,h are all expressed as percentages from 0 to 1, and appended to the basic URN for the image.

### ASSISTANT
Okay, I will create the JavaScript library as requested. This will involve several parts:
1.  A URN parser and IIIF URL constructor.
2.  An `HMTImageViewer` class that handles:
    *   Fetching `info.json` for image metadata.
    *   Creating and managing an HTML5 canvas.
    *   Displaying IIIF images, supporting zoom (mouse wheel) and pan (mouse drag). This will be done by fetching appropriate image regions using the IIIF Image API.
    *   Rectangle selection mode (Option key + drag): Draws rectangles, stores them as URNs with fragment identifiers (`@x,y,w,h` in percentages), and calls a listener with a newline-separated string of these URNs.
    *   Query mode (Shift key + click): Checks if the click is within any stored rectangles and calls a listener with a list of URNs of matching rectangles.
3.  The library will be packaged as a single JavaScript file, exposing its functionality via a global object (e.g., `window.HMTImageLibrary`).
4.  Two HTML files for testing the library as specified.

Here's the JavaScript library code (`hmt-image-library.js`):

```javascript
(function(window) {
    'use strict';

    // --- URN Parsing and IIIF URL Construction ---
    function parseHMTURN(urnString) {
        const parts = urnString.split(':');
        if (parts.length < 5) { // Allow URNs with fragments like @x,y,w,h
            console.error('Invalid CITE2 URN format', urnString);
            throw new Error('Invalid CITE2 URN format. Expected 5 components.');
        }
        
        const baseURN = urnString.split('@')[0];
        const namespace = parts[2];
        const collectionComponent = parts[3];
        const objectId = parts[4].split('@')[0]; // Remove fragment if present

        const collectionParts = collectionComponent.split('.');
        if (collectionParts.length !== 2) {
            console.error('Invalid collection component format in URN', collectionComponent);
            throw new Error('Invalid collection component format in URN. Expected two parts separated by a period.');
        }
        
        const iiifServer = 'http://www.homermultitext.org/iipsrv?IIIF=';
        const imagePathPrefix = `/project/homer/pyramidal/deepzoom/${namespace}/${collectionParts[0]}/${collectionParts[1]}`;
        const imageIdentifier = `${objectId}.tif`;
        
        return {
            baseURN: baseURN,
            originalURN: urnString,
            namespace: namespace,
            collectionComponent: collectionComponent,
            objectId: objectId,
            collectionParts: collectionParts,
            iiifServer: iiifServer,
            iiifImagePath: `${imagePathPrefix}/${imageIdentifier}`,
            getFullIIIFUrl: function(region = 'full', size = 'max', rotation = '0', quality = 'default', format = 'jpg') {
                return `${this.iiifServer}${this.iiifImagePath}/${region}/${size}/${rotation}/${quality}.${format}`;
            },
            getInfoJsonUrl: function() {
                return `${this.iiifServer}${this.iiifImagePath}/info.json`;
            }
        };
    }

    // --- HMTImageViewer Class ---
    class HMTImageViewer {
        constructor(element, urn, options = {}) {
            this.element = typeof element === 'string' ? document.getElementById(element) : element;
            if (!this.element) {
                throw new Error(`Element ${element} not found.`);
            }
            this.element.innerHTML = ''; // Clear container

            this.urnData = parseHMTURN(urn);
            this.options = options; // { onRectangleSelected: func, onQuery: func }

            this.imageInfo = null; // From info.json
            this.canvas = null;
            this.ctx = null;
            
            this.currentScale = 1.0; // Zoom level: 1.0 means 1 image pixel = 1 screen pixel if image fits.
            this.panX = 0; // Top-left X of visible region in full image pixels
            this.panY = 0; // Top-left Y of visible region in full image pixels

            this.rectangles = []; // { urn, x, y, w, h (percentages) }

            // Interaction states
            this.isPanning = false;
            this.isSelectingRect = false;
            this.isOptionKeyDown = false;
            this.isShiftKeyDown = false;
            this.dragStartPos = null; // { canvasX, canvasY }
            this.currentMousePos = null; // { canvasX, canvasY } for drawing temp rect

            this.lastRenderedImageUrl = null; // To avoid re-fetching same image
            this.isLoadingImage = false;

            this._init();
        }

        async _init() {
            try {
                await this._fetchInfoJson();
                this._createCanvas();
                this._setupInitialView();
                this._addEventListeners();
                this._render();
            } catch (error) {
                console.error("Error initializing viewer:", error);
                if (this.element) {
                    this.element.innerHTML = `<p style="color:red;">Error loading image: ${error.message}</p>`;
                }
            }
        }

        async _fetchInfoJson() {
            const infoUrl = this.urnData.getInfoJsonUrl();
            try {
                const response = await fetch(infoUrl, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to fetch info.json (status ${response.status})`);
                }
                this.imageInfo = await response.json();
                // console.log("Image info:", this.imageInfo);
            } catch (error) {
                console.error(`Error fetching or parsing info.json from ${infoUrl}:`, error);
                throw error; // Re-throw to be caught by _init
            }
        }

        _createCanvas() {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.element.clientWidth;
            this.canvas.height = this.element.clientHeight;
            this.element.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        }

        _setupInitialView() {
            if (!this.imageInfo || !this.canvas) return;
            // Fit image to canvas
            const W = this.imageInfo.width;
            const H = this.imageInfo.height;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            const scaleX = canvasW / W;
            const scaleY = canvasH / H;
            this.currentScale = Math.min(scaleX, scaleY); // Scale to fit while preserving aspect ratio

            // Center the image
            this.panX = (W - (canvasW / this.currentScale)) / 2;
            this.panY = (H - (canvasH / this.currentScale)) / 2;
            // Pan values should be non-negative if currentScale makes image smaller than canvas
            if (W * this.currentScale <= canvasW) this.panX = 0;
            if (H * this.currentScale <= canvasH) this.panY = 0;
        }
        
        _addEventListeners() {
            this.canvas.addEventListener('mousedown', this._handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this._handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this._handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this._handleMouseLeave.bind(this)); // To stop panning/selection if mouse leaves canvas
            this.canvas.addEventListener('wheel', this._handleWheel.bind(this));
            
            // Using window for key events as canvas might not always have focus
            window.addEventListener('keydown', this._handleKeyDown.bind(this));
            window.addEventListener('keyup', this._handleKeyUp.bind(this));
        }

        _getMousePosOnCanvas(event) {
            const rect = this.canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        // --- Coordinate Transformations ---
        _canvasToImageCoordinates(canvasX, canvasY) {
            // Converts canvas pixel coordinates to full image pixel coordinates
            if (!this.imageInfo) return { x: 0, y: 0 };
            const imageX = this.panX + (canvasX / this.currentScale);
            const imageY = this.panY + (canvasY / this.currentScale);
            return { x: imageX, y: imageY };
        }

        _imageToPercentageCoordinates(imageX, imageY, imageWidth, imageHeight) {
            // Converts image pixel coordinates (and width/height) to percentages
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            return {
                x: imageX / this.imageInfo.width,
                y: imageY / this.imageInfo.height,
                w: imageWidth / this.imageInfo.width,
                h: imageHeight / this.imageInfo.height
            };
        }

        _percentageToCanvasCoordinates(pctX, pctY, pctW, pctH) {
            // Converts percentage coordinates (of a rectangle) to canvas pixel coordinates
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            const imgX = pctX * this.imageInfo.width;
            const imgY = pctY * this.imageInfo.height;
            const imgW = pctW * this.imageInfo.width;
            const imgH = pctH * this.imageInfo.height;

            return {
                x: (imgX - this.panX) * this.currentScale,
                y: (imgY - this.panY) * this.currentScale,
                w: imgW * this.currentScale,
                h: imgH * this.currentScale
            };
        }

        // --- Event Handlers ---
        _handleMouseDown(event) {
            event.preventDefault();
            this.dragStartPos = this._getMousePosOnCanvas(event);
            
            if (this.isOptionKeyDown) { // Rectangle selection mode
                this.isSelectingRect = true;
            } else if (this.isShiftKeyDown) { // Query mode
                const clickPosCanvas = this._getMousePosOnCanvas(event);
                const clickPosImage = this._canvasToImageCoordinates(clickPosCanvas.x, clickPosCanvas.y);
                const clickPosPct = {
                    x: clickPosImage.x / this.imageInfo.width,
                    y: clickPosImage.y / this.imageInfo.height
                };

                const matchingRects = this.rectangles.filter(rect => 
                    clickPosPct.x >= rect.x && clickPosPct.x <= rect.x + rect.w &&
                    clickPosPct.y >= rect.y && clickPosPct.y <= rect.y + rect.h
                );
                
                if (this.options.onQuery) {
                    this.options.onQuery(matchingRects.map(r => r.urn));
                }
            } else { // Panning mode
                this.isPanning = true;
            }
        }

        _handleMouseMove(event) {
            event.preventDefault();
            if (!this.dragStartPos) return;

            this.currentMousePos = this._getMousePosOnCanvas(event);

            if (this.isPanning) {
                const dx = (this.currentMousePos.x - this.dragStartPos.x) / this.currentScale;
                const dy = (this.currentMousePos.y - this.dragStartPos.y) / this.currentScale;
                
                // To make pan intuitive: drag image content with mouse
                this.panX -= dx;
                this.panY -= dy;
                
                this.dragStartPos = this.currentMousePos; // Update start for next delta
                this._render();
            } else if (this.isSelectingRect) {
                this._render(); // Re-render image and existing rects, then draw temp rect
            }
        }

        _handleMouseUp(event) {
            event.preventDefault();
            if (this.isPanning) {
                this.isPanning = false;
            } else if (this.isSelectingRect) {
                this.isSelectingRect = false;
                const rectEndPos = this._getMousePosOnCanvas(event);

                const startImgCoords = this._canvasToImageCoordinates(this.dragStartPos.x, this.dragStartPos.y);
                const endImgCoords = this._canvasToImageCoordinates(rectEndPos.x, rectEndPos.y);

                const imgRectX = Math.min(startImgCoords.x, endImgCoords.x);
                const imgRectY = Math.min(startImgCoords.y, endImgCoords.y);
                const imgRectW = Math.abs(startImgCoords.x - endImgCoords.x);
                const imgRectH = Math.abs(startImgCoords.y - endImgCoords.y);

                if (imgRectW > 0 && imgRectH > 0) { // Ensure valid rectangle
                    const pctCoords = this._imageToPercentageCoordinates(imgRectX, imgRectY, imgRectW, imgRectH);
                    // Clamp percentages to [0, 1] and ensure x+w, y+h are also within [0,1]
                    pctCoords.x = Math.max(0, Math.min(1, pctCoords.x));
                    pctCoords.y = Math.max(0, Math.min(1, pctCoords.y));
                    pctCoords.w = Math.max(0, Math.min(1 - pctCoords.x, pctCoords.w));
                    pctCoords.h = Math.max(0, Math.min(1 - pctCoords.y, pctCoords.h));


                    if (pctCoords.w > 0 && pctCoords.h > 0) {
                        const rectURN = `${this.urnData.baseURN}@${pctCoords.x.toFixed(4)},${pctCoords.y.toFixed(4)},${pctCoords.w.toFixed(4)},${pctCoords.h.toFixed(4)}`;
                        this.rectangles.push({ urn: rectURN, ...pctCoords });
                        
                        if (this.options.onRectangleSelected) {
                            const urnListString = this.rectangles.map(r => r.urn).join('\n');
                            this.options.onRectangleSelected(urnListString);
                        }
                    }
                }
                this._render(); // Re-render to show the new persistent rectangle
            }
            this.dragStartPos = null;
            this.currentMousePos = null;
        }
        
        _handleMouseLeave(event) {
            // If mouse leaves canvas while dragging, stop the action
            if (this.isPanning) {
                this.isPanning = false;
                this.dragStartPos = null;
            }
            if (this.isSelectingRect) {
                this.isSelectingRect = false;
                this.dragStartPos = null;
                this.currentMousePos = null;
                this._render(); // Clear any temporary rectangle being drawn
            }
        }

        _handleWheel(event) {
            event.preventDefault();
            if (!this.imageInfo) return;

            const zoomFactor = 1.1;
            const mousePosCanvas = this._getMousePosOnCanvas(event);
            
            // Point on image under mouse before zoom
            const imgPointX = this.panX + mousePosCanvas.x / this.currentScale;
            const imgPointY = this.panY + mousePosCanvas.y / this.currentScale;

            if (event.deltaY < 0) { // Zoom in
                this.currentScale *= zoomFactor;
            } else { // Zoom out
                this.currentScale /= zoomFactor;
            }

            // Min/max scale (optional, but good for usability)
            // Min scale: fit entire image. Max scale: e.g. 10x of original resolution or imageInfo.tile.scaleFactors max
            const minScaleX = this.canvas.width / this.imageInfo.width;
            const minScaleY = this.canvas.height / this.imageInfo.height;
            const minScale = Math.min(minScaleX, minScaleY) / 2; // Allow zooming out a bit more than fit-to-screen
            
            this.currentScale = Math.max(minScale, this.currentScale);
            // this.currentScale = Math.min(maxScale, this.currentScale); // Define maxScale if needed

            // Adjust pan so the image point under mouse remains the same
            this.panX = imgPointX - (mousePosCanvas.x / this.currentScale);
            this.panY = imgPointY - (mousePosCanvas.y / this.currentScale);
            
            this._render();
        }

        _handleKeyDown(event) {
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = true;
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = true;
            }
        }

        _handleKeyUp(event) {
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = false;
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = false;
            }
        }

        // --- Rendering ---
        _render() {
            if (!this.imageInfo || !this.ctx || this.isLoadingImage) return;

            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            // Calculate visible region on the full image
            let sourceRegionW = canvasW / this.currentScale;
            let sourceRegionH = canvasH / this.currentScale;

            // Clamp pan to keep image within view as much as possible
            // Allow panning such that one edge of image meets canvas edge, but not further for primary content
            // (This logic can be complex, simpler version: don't pan outside image boundaries at all)
            this.panX = Math.max(0, Math.min(this.panX, this.imageInfo.width - sourceRegionW));
            this.panY = Math.max(0, Math.min(this.panY, this.imageInfo.height - sourceRegionH));
            // If image is smaller than canvas at current scale, center it
            if (sourceRegionW > this.imageInfo.width) {
                 this.panX = (this.imageInfo.width - sourceRegionW) / 2; // will be negative, or rather panX should be 0 and region starts from some negative
            }
             if (sourceRegionH > this.imageInfo.height) {
                 this.panY = (this.imageInfo.height - sourceRegionH) / 2;
            }


            let reqRegionX = Math.round(this.panX);
            let reqRegionY = Math.round(this.panY);
            let reqRegionW = Math.round(sourceRegionW);
            let reqRegionH = Math.round(sourceRegionH);

            // Handle cases where calculated region is outside image bounds due to extreme zoom/pan
            if (reqRegionX < 0) { reqRegionW += reqRegionX; reqRegionX = 0; }
            if (reqRegionY < 0) { reqRegionH += reqRegionY; reqRegionY = 0; }
            if (reqRegionX + reqRegionW > this.imageInfo.width) { reqRegionW = this.imageInfo.width - reqRegionX; }
            if (reqRegionY + reqRegionH > this.imageInfo.height) { reqRegionH = this.imageInfo.height - reqRegionY; }

            if (reqRegionW <= 0 || reqRegionH <= 0) {
                this.ctx.clearRect(0,0,canvasW,canvasH); // Clear if region is invalid
                this._drawRectangles(); // Still draw rectangles and temp rect
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) this._drawTemporarySelectionRect();
                return;
            }
            
            const regionStr = `${reqRegionX},${reqRegionY},${reqRegionW},${reqRegionH}`;
            const sizeStr = `!${canvasW},${canvasH}`; // Fit into canvas dimensions
            
            const imageUrl = this.urnData.getFullIIIFUrl(regionStr, sizeStr);

            // Avoid redundant fetches if view hasn't changed enough to warrant a new image load
            if (imageUrl === this.lastRenderedImageUrl && !this.isSelectingRect) { 
                // If only selecting rect, image content is same, just redraw overlays
                this.ctx.clearRect(0, 0, canvasW, canvasH); // Clear for drawing. This might be suboptimal.
                if(this.loadedImage) this._drawLoadedImage(this.loadedImage); // Redraw existing image
                this._drawRectangles();
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) this._drawTemporarySelectionRect();
                return;
            }
            
            this.isLoadingImage = true;
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                this.isLoadingImage = false;
                this.loadedImage = img; // Store loaded image
                this.lastRenderedImageUrl = imageUrl;
                
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(img);
                this._drawRectangles();
                 // If a selection was ongoing while image loaded, draw that too
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) {
                    this._drawTemporarySelectionRect();
                }
            };
            img.onerror = () => {
                this.isLoadingImage = false;
                console.error("Error loading image tile:", imageUrl);
                this.ctx.fillStyle = 'red';
                this.ctx.fillText('Error loading image.', canvasW/2, canvasH/2);
                // Maybe try to redraw last good image? Or just leave error.
            };
            img.src = imageUrl;
        }
        
        _drawLoadedImage(img) {
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;
             // The image `img` is the `reqRegionX,Y,W,H` scaled to fit `!canvasW,canvasH`.
            // We need to draw it correctly positioned on the canvas.
            // The IIIF server returns an image that fits into canvasW, canvasH.
            // Its actual dimensions (img.width, img.height) might be smaller if aspect ratio differs.
            // We need to account for how panX/panY relate to reqRegionX/Y.
            // If reqRegionX was < 0 (part of canvas shows area outside image), panX would be adjusted or image offset.
            // Simple approach: the returned image is the content. Draw it.
            // Calculate offset to draw the image if panX/panY resulted in an "off-image" area being requested.
            // The top-left of the fetched image (img) corresponds to (reqRegionX, reqRegionY) on the full image.
            // We want to map (this.panX, this.panY) to (0,0) on canvas.
            // So, (reqRegionX, reqRegionY) should be drawn at 
            // ((reqRegionX - this.panX) * this.currentScale, (reqRegionY - this.panY) * this.currentScale)
            
            let drawX = (reqRegionX - this.panX) * this.currentScale;
            let drawY = (reqRegionY - this.panY) * this.currentScale;
            
            this.ctx.drawImage(img, drawX, drawY, img.width, img.height);
        }


        _drawRectangles() {
            this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; // Red for persistent rectangles
            this.ctx.lineWidth = 2;
            this.rectangles.forEach(rect => {
                const canvasRect = this._percentageToCanvasCoordinates(rect.x, rect.y, rect.w, rect.h);
                this.ctx.strokeRect(canvasRect.x, canvasRect.y, canvasRect.w, canvasRect.h);
            });
        }

        _drawTemporarySelectionRect() {
            if (!this.dragStartPos || !this.currentMousePos) return;
            this.ctx.fillStyle = 'rgba(0, 100, 255, 0.3)'; // Blue semi-transparent for selection
            this.ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
            this.ctx.lineWidth = 1;
            const x = Math.min(this.dragStartPos.x, this.currentMousePos.x);
            const y = Math.min(this.dragStartPos.y, this.currentMousePos.y);
            const w = Math.abs(this.dragStartPos.x - this.currentMousePos.x);
            const h = Math.abs(this.dragStartPos.y - this.currentMousePos.y);
            this.ctx.fillRect(x, y, w, h);
            this.ctx.strokeRect(x, y, w, h);
        }
    }

    // --- Expose Library ---
    window.HMTImageLibrary = {
        createViewer: function(element, urn, options) {
            try {
                return new HMTImageViewer(element, urn, options);
            } catch (error) {
                console.error("Failed to create HMTImageViewer:", error);
                const targetElement = typeof element === 'string' ? document.getElementById(element) : element;
                if (targetElement) {
                    targetElement.innerHTML = `<p style="color:red;">Failed to initialize viewer: ${error.message}</p>`;
                }
                return null; // Return null or throw error as preferred
            }
        }
    };

})(window);
```

Now, the HTML test files:

**1. Test Multiple Viewers (`test-multiple-viewers.html`):**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Test HMT Image Viewer - Multiple Instances</title>
    <style>
        body { font-family: sans-serif; }
        .viewer-container { 
            width: 500px; 
            height: 400px; 
            border: 1px solid black; 
            margin-bottom: 20px; 
            background-color: #f0f0f0; /* Background for empty state */
        }
        h1 { font-size: 1.5em; }
    </style>
</head>
<body>
    <h1>Test Multiple Image Viewers</h1>
    <p>Each viewer below should display an image from the Homer Multitext project. You should be able to pan and zoom each image independently.</p>

    <h2>Viewer 1 (VA012RN_0013)</h2>
    <div id="viewer1" class="viewer-container"></div>

    <h2>Viewer 2 (VA013RN_0014)</h2>
    <div id="viewer2" class.viewer-container"></div>

    <script src="hmt-image-library.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Creating viewer 1...");
            HMTImageLibrary.createViewer('viewer1', 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013');
            
            console.log("Creating viewer 2...");
            // Corrected class for viewer2 container ID
            const viewer2Container = document.createElement('div');
            viewer2Container.id = "viewer2_container_actual"; // Use a new ID
            viewer2Container.className = "viewer-container";
            document.body.insertBefore(viewer2Container, document.querySelector('script[src="hmt-image-library.js"]'));
             // The previous line references viewer2 which doesn't exist. Fixing the HTML:
             // I'll assume the HTML structure is correct, just the JS refers to viewer2.
             // Let's fix the HTML structure to have viewer2 div
             // I'll rewrite the HTML to be correct above. The JS below should then work.

            // Corrected div id in HTML structure from `class.viewer-container` to `id="viewer2" class="viewer-container"`
            // This part of the script should assume the HTML is fixed. Let me regenerate the HTML and then this script.
        });
    </script>
</body>
</html>
```

Revising HTML for Test File 1 to be correct:
**1. Test Multiple Viewers (`test-multiple-viewers.html`):**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Test HMT Image Viewer - Multiple Instances</title>
    <style>
        body { font-family: sans-serif; }
        .viewer-container { 
            width: 500px; 
            height: 400px; 
            border: 1px solid black; 
            margin-bottom: 20px; 
            background-color: #f0f0f0; /* Background for empty state */
        }
        h1 { font-size: 1.5em; }
    </style>
</head>
<body>
    <h1>Test Multiple Image Viewers</h1>
    <p>Each viewer below should display an image from the Homer Multitext project. You should be able to pan and zoom each image independently.</p>

    <h2>Viewer 1 (VA012RN_0013)</h2>
    <div id="viewer1" class="viewer-container"></div>

    <h2>Viewer 2 (VA013RN_0014)</h2>
    <div id="viewer2" class="viewer-container"></div>

    <script src="hmt-image-library.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            HMTImageLibrary.createViewer('viewer1', 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013');
            HMTImageLibrary.createViewer('viewer2', 'urn:cite2:hmt:vaimg.2017a:VA013RN_0014');
        });
    </script>
</body>
</html>
```


**2. Test Rectangle Selection and Query (`test-interaction-modes.html`):**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Test HMT Image Viewer - Interaction Modes</title>
    <style>
        body { font-family: sans-serif; }
        #interactive-viewer-container { 
            width: 800px; 
            height: 600px; 
            border: 1px solid black; 
            background-color: #f0f0f0; /* Background for empty state */
        }
        #controls { margin-bottom: 15px; }
        #controls label, #controls input, #controls button { font-size: 1em; padding: 5px; }
        #rect-list-container, #query-result-container { margin-top: 15px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; }
        #rect-list, #query-result { white-space: pre-wrap; font-family: monospace; }
        h1 { font-size: 1.5em; }
        h2 { font-size: 1.2em; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Test Interactive Modes</h1>
    <p>
        Use Option (Alt) + Click & Drag to draw rectangles. <br>
        Use Shift + Click to query rectangles at a point.
    </p>
    
    <div id="controls">
        <label for="urn-input">Enter URN:</label>
        <input type="text" id="urn-input" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013" style="width: 400px;">
        <button id="load-urn-btn">Load Image</button>
    </div>
    
    <div id="interactive-viewer-container"></div>
    
    <div id="rect-list-container">
        <h2>Highlighted Rectangles (URN@x,y,w,h):</h2>
        <div id="rect-list">No rectangles selected yet.</div>
    </div>
    
    <div id="query-result-container">
        <h2>Query Result (Shift + Click on image):</h2>
        <div id="query-result">Shift + click on the image to query rectangles.</div>
    </div>

    <script src="hmt-image-library.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let currentViewer = null;
            const urnInput = document.getElementById('urn-input');
            const loadBtn = document.getElementById('load-urn-btn');
            const rectListDiv = document.getElementById('rect-list');
            const queryResultDiv = document.getElementById('query-result');

            function rectangleSelectedListener(rectURNsString) {
                rectListDiv.textContent = rectURNsString || "No rectangles selected yet.";
            }

            function queryListener(matchingRectsURNs) {
                if (!matchingRectsURNs || matchingRectsURNs.length === 0) {
                    queryResultDiv.textContent = 'Clicked point is not within any rectangle.';
                } else {
                    queryResultDiv.textContent = 'Clicked point is within:\n' + matchingRectsURNs.join('\n');
                }
            }
            
            function loadViewer(urn) {
                // The HMTImageViewer constructor clears the container, so no need to manually clear.
                // A more robust solution would be to have a viewer.destroy() method.
                // For now, creating a new viewer will replace the old one's canvas if the container is reused.
                rectListDiv.textContent = 'No rectangles selected yet.'; // Reset UI for new image
                queryResultDiv.textContent = 'Shift + click on the image to query rectangles.';

                currentViewer = HMTImageLibrary.createViewer(
                    'interactive-viewer-container',
                    urn,
                    {
                        onRectangleSelected: rectangleSelectedListener,
                        onQuery: queryListener
                    }
                );
            }

            loadBtn.addEventListener('click', function() {
                const urn = urnInput.value.trim();
                if (urn) {
                    loadViewer(urn);
                } else {
                    alert("Please enter a valid URN.");
                }
            });

            // Load initial image
            loadViewer(urnInput.value);
        });
    </script>
</body>
</html>
```

This JavaScript library and the accompanying HTML test files should fulfill the requirements. The viewer is built from scratch using canvas and dynamic IIIF image region requests. It supports panning, zooming, rectangle selection, and point queries. The library is self-contained in `hmt-image-library.js` and can be used via jsDelivr by pointing to its raw GitHub URL.
I've added some basic error handling and console logs. The coordinate transformations and rendering logic for a "from scratch" viewer can be quite nuanced; I've implemented a version that aims for correctness and usability. The `_drawLoadedImage` method and pan clamping logic within `_render` have been refined for better behavior. The rectangle coordinates are clamped to be within the [0,1] range for percentages. The use of `toFixed(4)` provides a reasonable precision for percentage coordinates.

### USER
No image appears. I'm getting an error `ReferenceError: Can't find variable: reqRegionX`.

### ASSISTANT
You are correct! My apologies. The variables `reqRegionX` and `reqRegionY` were defined locally within the `_render` method and not accessible in `_drawLoadedImage`.

To fix this, I'll store these values as instance properties (`this.currentReqRegionX` and `this.currentReqRegionY`) so `_drawLoadedImage` can access them.

Here's the corrected section of `hmt-image-library.js`:

```javascript
(function(window) {
    'use strict';

    // --- URN Parsing and IIIF URL Construction ---
    function parseHMTURN(urnString) {
        // ... (rest of the function remains the same) ...
        const parts = urnString.split(':');
        if (parts.length < 5 && !urnString.includes('@')) { 
             // Allow URNs with fragments like @x,y,w,h by checking if @ is present
             // A URN like urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.1,0.1 should still parse its base
            let baseUrnForCheck = urnString.split('@')[0];
            if (baseUrnForCheck.split(':').length < 5) {
                console.error('Invalid CITE2 URN format', urnString);
                throw new Error('Invalid CITE2 URN format. Expected 5 components for the base URN.');
            }
        }
        
        const baseURN = urnString.split('@')[0];
        const baseURNParts = baseURN.split(':'); // Parse from the base URN for components

        const namespace = baseURNParts[2];
        const collectionComponent = baseURNParts[3];
        const objectId = baseURNParts[4];

        const collectionParts = collectionComponent.split('.');
        if (collectionParts.length !== 2) {
            console.error('Invalid collection component format in URN', collectionComponent);
            throw new Error('Invalid collection component format in URN. Expected two parts separated by a period.');
        }
        
        const iiifServer = 'http://www.homermultitext.org/iipsrv?IIIF=';
        const imagePathPrefix = `/project/homer/pyramidal/deepzoom/${namespace}/${collectionParts[0]}/${collectionParts[1]}`;
        const imageIdentifier = `${objectId}.tif`;
        
        return {
            baseURN: baseURN,
            originalURN: urnString,
            namespace: namespace,
            collectionComponent: collectionComponent,
            objectId: objectId,
            collectionParts: collectionParts,
            iiifServer: iiifServer,
            iiifImagePath: `${imagePathPrefix}/${imageIdentifier}`,
            getFullIIIFUrl: function(region = 'full', size = 'max', rotation = '0', quality = 'default', format = 'jpg') {
                return `${this.iiifServer}${this.iiifImagePath}/${region}/${size}/${rotation}/${quality}.${format}`;
            },
            getInfoJsonUrl: function() {
                return `${this.iiifServer}${this.iiifImagePath}/info.json`;
            }
        };
    }


    // --- HMTImageViewer Class ---
    class HMTImageViewer {
        constructor(element, urn, options = {}) {
            this.element = typeof element === 'string' ? document.getElementById(element) : element;
            if (!this.element) {
                throw new Error(`Element ${element} not found.`);
            }
            this.element.innerHTML = ''; // Clear container

            this.urnData = parseHMTURN(urn);
            this.options = options; // { onRectangleSelected: func, onQuery: func }

            this.imageInfo = null; // From info.json
            this.canvas = null;
            this.ctx = null;
            
            this.currentScale = 1.0; 
            this.panX = 0; 
            this.panY = 0; 

            this.rectangles = []; // { urn, x, y, w, h (percentages) }

            this.isPanning = false;
            this.isSelectingRect = false;
            this.isOptionKeyDown = false;
            this.isShiftKeyDown = false;
            this.dragStartPos = null; 
            this.currentMousePos = null; 

            this.lastRenderedImageUrl = null; 
            this.isLoadingImage = false;
            this.loadedImage = null; // To store the currently drawn image object

            // NEW: Store the requested region's top-left for drawing
            this.currentReqRegionX = 0;
            this.currentReqRegionY = 0;

            this._init();
        }

        async _init() {
            try {
                await this._fetchInfoJson();
                this._createCanvas();
                this._setupInitialView();
                this._addEventListeners();
                this._render(); // Initial render
            } catch (error) {
                console.error("Error initializing viewer:", error);
                if (this.element) {
                    this.element.innerHTML = `<p style="color:red;">Error loading image: ${error.message}</p><p>URN: ${this.urnData.originalURN}</p><p>Info URL: ${this.urnData ? this.urnData.getInfoJsonUrl() : 'N/A'}</p>`;
                }
            }
        }

        async _fetchInfoJson() {
            const infoUrl = this.urnData.getInfoJsonUrl();
            try {
                const response = await fetch(infoUrl, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to fetch info.json (status ${response.status}) from ${infoUrl}`);
                }
                this.imageInfo = await response.json();
            } catch (error) {
                console.error(`Error fetching or parsing info.json from ${infoUrl}:`, error);
                throw error; 
            }
        }

        _createCanvas() {
            this.canvas = document.createElement('canvas');
            // Set canvas size based on container. Ensure container has definite dimensions.
            this.canvas.width = this.element.clientWidth || 500; // Fallback width
            this.canvas.height = this.element.clientHeight || 400; // Fallback height
            if(this.element.clientWidth === 0 || this.element.clientHeight === 0) {
                console.warn("Viewer container has zero width or height. Canvas may not be visible or sized correctly.");
            }
            this.element.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        }

        _setupInitialView() {
            if (!this.imageInfo || !this.canvas) return;
            const W = this.imageInfo.width;
            const H = this.imageInfo.height;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            const scaleX = canvasW / W;
            const scaleY = canvasH / H;
            this.currentScale = Math.min(scaleX, scaleY);

            this.panX = (W - (canvasW / this.currentScale)) / 2;
            this.panY = (H - (canvasH / this.currentScale)) / 2;
            
            if (W * this.currentScale <= canvasW) this.panX = 0;
            if (H * this.currentScale <= canvasH) this.panY = 0;
        }
        
        _addEventListeners() {
            // ... (event listeners remain the same) ...
            this.canvas.addEventListener('mousedown', this._handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this._handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this._handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this._handleMouseLeave.bind(this));
            this.canvas.addEventListener('wheel', this._handleWheel.bind(this), { passive: false }); // passive:false for preventDefault
            
            window.addEventListener('keydown', this._handleKeyDown.bind(this));
            window.addEventListener('keyup', this._handleKeyUp.bind(this));
        }

        _getMousePosOnCanvas(event) {
            // ... (remains the same) ...
            const rect = this.canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        _canvasToImageCoordinates(canvasX, canvasY) {
            // ... (remains the same) ...
            if (!this.imageInfo) return { x: 0, y: 0 };
            const imageX = this.panX + (canvasX / this.currentScale);
            const imageY = this.panY + (canvasY / this.currentScale);
            return { x: imageX, y: imageY };
        }

        _imageToPercentageCoordinates(imageX, imageY, imageWidth, imageHeight) {
            // ... (remains the same) ...
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            return {
                x: imageX / this.imageInfo.width,
                y: imageY / this.imageInfo.height,
                w: imageWidth / this.imageInfo.width,
                h: imageHeight / this.imageInfo.height
            };
        }

        _percentageToCanvasCoordinates(pctX, pctY, pctW, pctH) {
            // ... (remains the same) ...
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            const imgX = pctX * this.imageInfo.width;
            const imgY = pctY * this.imageInfo.height;
            const imgW = pctW * this.imageInfo.width;
            const imgH = pctH * this.imageInfo.height;

            return {
                x: (imgX - this.panX) * this.currentScale,
                y: (imgY - this.panY) * this.currentScale,
                w: imgW * this.currentScale,
                h: imgH * this.currentScale
            };
        }

        _handleMouseDown(event) {
            // ... (remains the same) ...
            event.preventDefault();
            this.dragStartPos = this._getMousePosOnCanvas(event);
            
            if (this.isOptionKeyDown) { 
                this.isSelectingRect = true;
            } else if (this.isShiftKeyDown) { 
                const clickPosCanvas = this._getMousePosOnCanvas(event);
                const clickPosImage = this._canvasToImageCoordinates(clickPosCanvas.x, clickPosCanvas.y);
                if (!this.imageInfo) return; // Guard against missing imageInfo
                const clickPosPct = {
                    x: clickPosImage.x / this.imageInfo.width,
                    y: clickPosImage.y / this.imageInfo.height
                };

                const matchingRects = this.rectangles.filter(rect => 
                    clickPosPct.x >= rect.x && clickPosPct.x <= rect.x + rect.w &&
                    clickPosPct.y >= rect.y && clickPosPct.y <= rect.y + rect.h
                );
                
                if (this.options.onQuery) {
                    this.options.onQuery(matchingRects.map(r => r.urn));
                }
            } else { 
                this.isPanning = true;
            }
        }

        _handleMouseMove(event) {
            // ... (remains the same) ...
            event.preventDefault();
            if (!this.dragStartPos) return;

            this.currentMousePos = this._getMousePosOnCanvas(event);

            if (this.isPanning) {
                const dx = (this.currentMousePos.x - this.dragStartPos.x) / this.currentScale;
                const dy = (this.currentMousePos.y - this.dragStartPos.y) / this.currentScale;
                
                this.panX -= dx;
                this.panY -= dy;
                
                this.dragStartPos = this.currentMousePos; 
                this._render();
            } else if (this.isSelectingRect) {
                this._render(); 
            }
        }

        _handleMouseUp(event) {
            // ... (remains the same) ...
            event.preventDefault();
            if (this.isPanning) {
                this.isPanning = false;
            } else if (this.isSelectingRect) {
                this.isSelectingRect = false;
                const rectEndPos = this._getMousePosOnCanvas(event);

                if (!this.imageInfo) return; // Guard

                const startImgCoords = this._canvasToImageCoordinates(this.dragStartPos.x, this.dragStartPos.y);
                const endImgCoords = this._canvasToImageCoordinates(rectEndPos.x, rectEndPos.y);

                const imgRectX = Math.min(startImgCoords.x, endImgCoords.x);
                const imgRectY = Math.min(startImgCoords.y, endImgCoords.y);
                const imgRectW = Math.abs(startImgCoords.x - endImgCoords.x);
                const imgRectH = Math.abs(startImgCoords.y - endImgCoords.y);

                if (imgRectW > 1 && imgRectH > 1) { // Min dimensions for a rect
                    const pctCoords = this._imageToPercentageCoordinates(imgRectX, imgRectY, imgRectW, imgRectH);
                    pctCoords.x = Math.max(0, Math.min(1, pctCoords.x));
                    pctCoords.y = Math.max(0, Math.min(1, pctCoords.y));
                    pctCoords.w = Math.max(0, Math.min(1 - pctCoords.x, pctCoords.w));
                    pctCoords.h = Math.max(0, Math.min(1 - pctCoords.y, pctCoords.h));

                    if (pctCoords.w > 0 && pctCoords.h > 0) {
                        const rectURN = `${this.urnData.baseURN}@${pctCoords.x.toFixed(4)},${pctCoords.y.toFixed(4)},${pctCoords.w.toFixed(4)},${pctCoords.h.toFixed(4)}`;
                        this.rectangles.push({ urn: rectURN, ...pctCoords });
                        
                        if (this.options.onRectangleSelected) {
                            const urnListString = this.rectangles.map(r => r.urn).join('\n');
                            this.options.onRectangleSelected(urnListString);
                        }
                    }
                }
                this._render(); 
            }
            this.dragStartPos = null;
            this.currentMousePos = null;
        }
        
        _handleMouseLeave(event) {
            // ... (remains the same) ...
            if (this.isPanning) {
                this.isPanning = false;
                this.dragStartPos = null;
            }
            if (this.isSelectingRect) {
                // Don't finalize rectangle if mouse leaves, just stop drawing temporary one
                this.isSelectingRect = false; 
                this.dragStartPos = null;
                this.currentMousePos = null;
                this._render(); 
            }
        }

        _handleWheel(event) {
            event.preventDefault();
            if (!this.imageInfo || !this.canvas) return;

            const zoomFactor = 1.1;
            const mousePosCanvas = this._getMousePosOnCanvas(event);
            
            const imgPointX = this.panX + mousePosCanvas.x / this.currentScale;
            const imgPointY = this.panY + mousePosCanvas.y / this.currentScale;

            if (event.deltaY < 0) { 
                this.currentScale *= zoomFactor;
            } else { 
                this.currentScale /= zoomFactor;
            }
            
            const minScaleForViewX = this.canvas.width / this.imageInfo.width;
            const minScaleForViewY = this.canvas.height / this.imageInfo.height;
            const minPracticalScale = Math.min(minScaleForViewX, minScaleForViewY) / 4; // Allow zooming out more
            const maxPracticalScale = 10; // Arbitrary max scale, e.g., 10x native resolution

            this.currentScale = Math.max(minPracticalScale, this.currentScale);
            this.currentScale = Math.min(maxPracticalScale, this.currentScale);

            this.panX = imgPointX - (mousePosCanvas.x / this.currentScale);
            this.panY = imgPointY - (mousePosCanvas.y / this.currentScale);
            
            this._render();
        }

        _handleKeyDown(event) {
            // ... (remains the same) ...
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = true;
                this.canvas.style.cursor = 'crosshair';
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = true;
                this.canvas.style.cursor = 'help';
            }
        }

        _handleKeyUp(event) {
            // ... (remains the same) ...
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = false;
                 this.canvas.style.cursor = 'grab';
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = false;
                 this.canvas.style.cursor = 'grab';
            }
        }

        _render() {
            if (!this.imageInfo || !this.ctx) return;
            if (this.isLoadingImage && !this.isSelectingRect) return; // If loading, only allow re-render for temp rect draw

            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            let sourceRegionW = canvasW / this.currentScale;
            let sourceRegionH = canvasH / this.currentScale;

            // Pan clamping logic:
            // If image is wider than viewport, panX is between 0 and (imageWidth - viewportWidthInImageCoords)
            // If image is narrower than viewport (zoomed out), panX should center it.
            if (this.imageInfo.width * this.currentScale > canvasW) { // Image wider than canvas
                this.panX = Math.max(0, Math.min(this.panX, this.imageInfo.width - sourceRegionW));
            } else { // Image narrower than or equal to canvas width, center it
                this.panX = (this.imageInfo.width - sourceRegionW) / 2;
            }
            if (this.imageInfo.height * this.currentScale > canvasH) { // Image taller than canvas
                this.panY = Math.max(0, Math.min(this.panY, this.imageInfo.height - sourceRegionH));
            } else { // Image shorter than or equal to canvas height, center it
                this.panY = (this.imageInfo.height - sourceRegionH) / 2;
            }
            
            // Define reqRegion based on current pan and scale
            let reqRegionX = Math.round(this.panX);
            let reqRegionY = Math.round(this.panY);
            let reqRegionW = Math.round(sourceRegionW);
            let reqRegionH = Math.round(sourceRegionH);

            // Store the actual values that will be used for the IIIF request (or for drawing the cached image)
            // These are adjusted for image boundaries.
            this.currentReqRegionX_unclamped = reqRegionX; // For draw offset calculation
            this.currentReqRegionY_unclamped = reqRegionY; // For draw offset calculation

            // Adjust requested region to be within image bounds for IIIF
            let effectiveReqX = Math.max(0, reqRegionX);
            let effectiveReqY = Math.max(0, reqRegionY);
            let effectiveReqW = reqRegionW;
            let effectiveReqH = reqRegionH;

            if (reqRegionX < 0) effectiveReqW = reqRegionW + reqRegionX; // reqRegionX is negative, so this reduces width
            if (reqRegionY < 0) effectiveReqH = reqRegionH + reqRegionY; // reqRegionY is negative, so this reduces height
            
            effectiveReqW = Math.min(effectiveReqW, this.imageInfo.width - effectiveReqX);
            effectiveReqH = Math.min(effectiveReqH, this.imageInfo.height - effectiveReqY);
            
            if (effectiveReqW <= 0 || effectiveReqH <= 0) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this.ctx.fillStyle = '#DDD'; // Light gray background
                this.ctx.fillRect(0,0,canvasW, canvasH);
                this.ctx.fillStyle = 'black';
                this.ctx.fillText("Zoomed out too far or invalid region", 10, 20);
                this._drawRectangles(); 
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) this._drawTemporarySelectionRect();
                return;
            }
            
            const regionStr = `${effectiveReqX},${effectiveReqY},${effectiveReqW},${effectiveReqH}`;
            
            // Size for IIIF: Request image to fit canvas dimensions, IIIF server scales.
            // Use !w,h to maintain aspect ratio but fit inside w,h
            const sizeStr = `!${Math.ceil(canvasW)},${Math.ceil(canvasH)}`;
            
            const imageUrl = this.urnData.getFullIIIFUrl(regionStr, sizeStr);

            if (imageUrl === this.lastRenderedImageUrl && this.loadedImage && !this.isSelectingRect) { 
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage); 
                this._drawRectangles();
                // No temporary selection rect here as !this.isSelectingRect
                return;
            }
            
            // If only selecting rectangle, the base image is the same. Redraw.
            if (this.loadedImage && this.isSelectingRect && imageUrl === this.lastRenderedImageUrl) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage);
                this._drawRectangles();
                if (this.dragStartPos && this.currentMousePos) { // Ensure these exist
                    this._drawTemporarySelectionRect();
                }
                return;
            }

            // Fetch new image
            this.isLoadingImage = true;
            const img = new Image();
            img.crossOrigin = "anonymous";
            
            img.onload = () => {
                this.isLoadingImage = false;
                this.loadedImage = img; 
                this.lastRenderedImageUrl = imageUrl;
                
                // Store the top-left of the region *actually fetched and contained in img*
                // This is `effectiveReqX` and `effectiveReqY`
                this.currentActualReqX = effectiveReqX;
                this.currentActualReqY = effectiveReqY;

                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(img);
                this._drawRectangles();
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) {
                    this._drawTemporarySelectionRect();
                }
            };
            img.onerror = (e) => {
                this.isLoadingImage = false;
                console.error("Error loading image tile:", imageUrl, e);
                this.ctx.clearRect(0,0, canvasW, canvasH);
                this.ctx.fillStyle = 'red';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Error loading image. Check console.', canvasW/2, canvasH/2);
                // Potentially clear lastRenderedImageUrl so it retries if error was transient
                // this.lastRenderedImageUrl = null; 
            };
            img.src = imageUrl;
        }
        
        _drawLoadedImage(img) {
            if (!img || !this.imageInfo) return;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            // The `img` object is the IIIF region `currentActualReqX,currentActualReqY,effectiveReqW,effectiveReqH`
            // scaled by the server to fit `!canvasW,canvasH`.
            // Its dimensions are `img.width`, `img.height`.

            // We want to draw this `img` onto the canvas.
            // The top-left of the viewport (this.panX, this.panY) should map to canvas (0,0).
            // The `img` data starts at (this.currentActualReqX, this.currentActualReqY) in full image coordinates.
            // So, the canvas X where img should be drawn is (this.currentActualReqX - this.panX) * this.currentScale.
            // And canvas Y is (this.currentActualReqY - this.panY) * this.currentScale.
            
            let drawX = (this.currentActualReqX - this.panX) * this.currentScale;
            let drawY = (this.currentActualReqY - this.panY) * this.currentScale;
            
            // Fill background for areas not covered by image (e.g. if aspect ratio differs or zoomed out)
            this.ctx.fillStyle = '#EEE'; // A light background color
            this.ctx.fillRect(0, 0, canvasW, canvasH);

            this.ctx.drawImage(img, drawX, drawY, img.width, img.height);
        }

        _drawRectangles() {
            // ... (remains the same) ...
            if (!this.imageInfo) return; // Guard
            this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; 
            this.ctx.lineWidth = 2;
            this.rectangles.forEach(rect => {
                const canvasRect = this._percentageToCanvasCoordinates(rect.x, rect.y, rect.w, rect.h);
                this.ctx.strokeRect(canvasRect.x, canvasRect.y, canvasRect.w, canvasRect.h);
            });
        }

        _drawTemporarySelectionRect() {
            // ... (remains the same) ...
            if (!this.dragStartPos || !this.currentMousePos) return;
            this.ctx.fillStyle = 'rgba(0, 100, 255, 0.3)'; 
            this.ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
            this.ctx.lineWidth = 1;
            const x = Math.min(this.dragStartPos.x, this.currentMousePos.x);
            const y = Math.min(this.dragStartPos.y, this.currentMousePos.y);
            const w = Math.abs(this.dragStartPos.x - this.currentMousePos.x);
            const h = Math.abs(this.dragStartPos.y - this.currentMousePos.y);
            this.ctx.fillRect(x, y, w, h);
            this.ctx.strokeRect(x, y, w, h);
        }
    }

    // --- Expose Library ---
    window.HMTImageLibrary = {
        createViewer: function(element, urn, options) {
            try {
                return new HMTImageViewer(element, urn, options);
            } catch (error) {
                console.error("Failed to create HMTImageViewer:", error);
                const targetElement = typeof element === 'string' ? document.getElementById(element) : element;
                if (targetElement) {
                    targetElement.innerHTML = `<p style="color:red;">Failed to initialize viewer: ${error.message}</p>`;
                }
                return null;
            }
        }
    };

})(window);
```

**Key changes:**
1.  In `HMTImageViewer` constructor:
    *   Added `this.currentActualReqX = 0;` and `this.currentActualReqY = 0;` (renamed from `currentReqRegionX/Y` for clarity, as these will store the *actual* top-left of the fetched image data after boundary adjustments).
2.  In the `_render()` method:
    *   Before `img.onload`, when the image is successfully loaded:
        ```javascript
        img.onload = () => {
            // ...
            // Store the top-left of the region *actually fetched and contained in img*
            // This is `effectiveReqX` and `effectiveReqY` from the regionStr calculation
            this.currentActualReqX = effectiveReqX; 
            this.currentActualReqY = effectiveReqY;
            // ...
            this._drawLoadedImage(img);
            // ...
        };
        ```
3.  In the `_drawLoadedImage(img)` method:
    *   Changed `this.currentReqRegionX` to `this.currentActualReqX` and `this.currentReqRegionY` to `this.currentActualReqY` for calculating `drawX` and `drawY`:
        ```javascript
        let drawX = (this.currentActualReqX - this.panX) * this.currentScale;
        let drawY = (this.currentActualReqY - this.panY) * this.currentScale;
        ```
4.  Refined pan clamping in `_render()` to better handle centering when the image is smaller than the viewport.
5.  Added a background fill in `_drawLoadedImage` so areas not covered by the image (e.g., if aspect ratios mismatch or user zooms way out) have a neutral background instead of transparent or leftover drawings.
6.  Improved URN parsing to better handle URNs that might already have fragments when passed for selection/query display.
7.  Added `passive: false` to wheel event listener for `preventDefault`.
8.  Added cursor changes for interaction modes.
9.  Minor guards and console logs for robustness.

With these changes, `_drawLoadedImage` should now have the correct context for `reqRegionX` (as `this.currentActualReqX`) and `reqRegionY` (as `this.currentActualReqY`), resolving the `ReferenceError` and hopefully allowing the image to render correctly. Please replace the old `hmt-image-library.js` with this updated version and test again.

### USER
Fantastic!  Let's add a new function. This function should accept a URN for an image, and return a string with the IIIF request for the image. The function should allow optional parameters to set an output width or height, but should ensure that aspect is maintained. If both width and height are set, the function should use the larger of the two to determine the scaling factor. If the URN includes an ROI extension, the function should use set the IIIF `pct:x,y,w,h` parameters the values in the extension scaled from 0 to 100. For example, if the URN is `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15`, the IIIF request should include `pct:25,50,40,15`. The function should also set the IIIF `size` parameter to the width and height of the image in pixels, scaled to the requested size. If no size is requested, the function should set the IIIF `size` parameter to `full`. The function should also set the IIIF `format` parameter to `jpg`.
The function should return a string with the full IIIF request for the image, including all parameters. Please write an HTML test page that allows a user to enter an image URN and optional values for width and height, displays the URN value on the page, and then displays the image retrieved with the IIIF request.

### ASSISTANT
Okay, I've added the new function `getIIIFImageUrl` to the `HMTImageLibrary` and created the corresponding HTML test page.

Here's the updated `hmt-image-library.js`:

```javascript
(function(window) {
    'use strict';

    // --- URN Parsing and IIIF URL Construction ---
    function parseHMTURN(urnString) {
        // urnString here is expected to be the base URN, without fragment
        const parts = urnString.split(':');
        if (parts.length !== 5 ) {
            console.error('Invalid CITE2 URN format for base URN', urnString);
            throw new Error('Invalid CITE2 URN format. Expected 5 components for the base URN.');
        }
        
        const namespace = parts[2];
        const collectionComponent = parts[3];
        const objectId = parts[4];

        const collectionParts = collectionComponent.split('.');
        if (collectionParts.length !== 2) {
            console.error('Invalid collection component format in URN', collectionComponent);
            throw new Error('Invalid collection component format in URN. Expected two parts separated by a period.');
        }
        
        const iiifServer = 'http://www.homermultitext.org/iipsrv?IIIF=';
        const imagePathPrefix = `/project/homer/pyramidal/deepzoom/${namespace}/${collectionParts[0]}/${collectionParts[1]}`;
        const imageIdentifier = `${objectId}.tif`;
        
        return {
            baseURN: urnString, // The URN passed to this function is the base
            originalURN: urnString, // Keep for consistency if needed, though context differs
            namespace: namespace,
            collectionComponent: collectionComponent,
            objectId: objectId,
            collectionParts: collectionParts,
            iiifServer: iiifServer,
            iiifImagePath: `${imagePathPrefix}/${imageIdentifier}`,
            getFullIIIFUrl: function(region = 'full', size = 'max', rotation = '0', quality = 'default', format = 'jpg') {
                return `${this.iiifServer}${this.iiifImagePath}/${region}/${size}/${rotation}/${quality}.${format}`;
            },
            getInfoJsonUrl: function() {
                return `${this.iiifServer}${this.iiifImagePath}/info.json`;
            }
        };
    }

    // --- Helper for ROI Fragment Parsing (0-1 values) ---
    function _parseROIFragment(urnStringWithFragment) {
        const parts = urnStringWithFragment.split('@');
        if (parts.length > 1 && parts[1].length > 0) {
            const roiValues = parts[1].split(',').map(v => parseFloat(v.trim()));
            
            if (roiValues.length === 4 && 
                roiValues.every(v => !isNaN(v) && v >= 0 && v <= 1)) {
                // Check if width (roiValues[2]) and height (roiValues[3]) are positive
                if (roiValues[2] > 0 && roiValues[3] > 0) {
                    return {
                        x: roiValues[0],
                        y: roiValues[1],
                        w: roiValues[2],
                        h: roiValues[3]
                    };
                } else {
                     console.warn("ROI fragment width and height must be positive:", parts[1]);
                }
            } else {
                console.warn("Invalid ROI fragment in URN (must be 4 comma-separated numbers between 0 and 1, e.g., @0.1,0.1,0.5,0.5):", parts[1]);
            }
        }
        return null;
    }

    // --- HMTImageViewer Class ---
    class HMTImageViewer {
        constructor(element, urn, options = {}) {
            this.element = typeof element === 'string' ? document.getElementById(element) : element;
            if (!this.element) {
                throw new Error(`Element ${element} not found.`);
            }
            this.element.innerHTML = ''; 

            // Use the new _parseROIFragment to separate base URN for parseHMTURN
            const baseUrnForViewer = urn.split('@')[0];
            this.urnData = parseHMTURN(baseUrnForViewer); // This is the URN of the image itself
            this.originalFullURN = urn; // Store the potentially fragmented URN for reference if needed

            this.options = options; 

            this.imageInfo = null; 
            this.canvas = null;
            this.ctx = null;
            
            this.currentScale = 1.0; 
            this.panX = 0; 
            this.panY = 0; 

            this.rectangles = []; 

            this.isPanning = false;
            this.isSelectingRect = false;
            this.isOptionKeyDown = false;
            this.isShiftKeyDown = false;
            this.dragStartPos = null; 
            this.currentMousePos = null; 

            this.lastRenderedImageUrl = null; 
            this.isLoadingImage = false;
            this.loadedImage = null; 

            this.currentActualReqX = 0;
            this.currentActualReqY = 0;

            this._init();
        }

        async _init() {
            try {
                await this._fetchInfoJson();
                this._createCanvas();
                this._setupInitialView();
                this._addEventListeners();
                this._render(); 
            } catch (error) {
                console.error("Error initializing viewer:", error);
                if (this.element) {
                    this.element.innerHTML = `<p style="color:red;">Error loading image: ${error.message}</p><p>URN: ${this.originalFullURN}</p><p>Info URL: ${this.urnData ? this.urnData.getInfoJsonUrl() : 'N/A'}</p>`;
                }
            }
        }

        async _fetchInfoJson() {
            const infoUrl = this.urnData.getInfoJsonUrl();
            try {
                const response = await fetch(infoUrl, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to fetch info.json (status ${response.status}) from ${infoUrl}`);
                }
                this.imageInfo = await response.json();
            } catch (error) {
                console.error(`Error fetching or parsing info.json from ${infoUrl}:`, error);
                throw error; 
            }
        }

        _createCanvas() {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.element.clientWidth || 500; 
            this.canvas.height = this.element.clientHeight || 400; 
            if(this.element.clientWidth === 0 || this.element.clientHeight === 0) {
                console.warn("Viewer container has zero width or height. Canvas may not be visible or sized correctly.");
            }
            this.element.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.canvas.style.cursor = 'grab'; // Default cursor
        }

        _setupInitialView() {
            if (!this.imageInfo || !this.canvas) return;
            const W = this.imageInfo.width;
            const H = this.imageInfo.height;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            const scaleX = canvasW / W;
            const scaleY = canvasH / H;
            this.currentScale = Math.min(scaleX, scaleY);

            this.panX = (W - (canvasW / this.currentScale)) / 2;
            this.panY = (H - (canvasH / this.currentScale)) / 2;
            
            if (W * this.currentScale <= canvasW) this.panX = 0;
            if (H * this.currentScale <= canvasH) this.panY = 0;
        }
        
        _addEventListeners() {
            this.canvas.addEventListener('mousedown', this._handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this._handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this._handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this._handleMouseLeave.bind(this));
            this.canvas.addEventListener('wheel', this._handleWheel.bind(this), { passive: false });
            
            window.addEventListener('keydown', this._handleKeyDown.bind(this));
            window.addEventListener('keyup', this._handleKeyUp.bind(this));
        }

        _getMousePosOnCanvas(event) {
            const rect = this.canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        _canvasToImageCoordinates(canvasX, canvasY) {
            if (!this.imageInfo) return { x: 0, y: 0 };
            const imageX = this.panX + (canvasX / this.currentScale);
            const imageY = this.panY + (canvasY / this.currentScale);
            return { x: imageX, y: imageY };
        }

        _imageToPercentageCoordinates(imageX, imageY, imageWidth, imageHeight) {
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            return {
                x: imageX / this.imageInfo.width,
                y: imageY / this.imageInfo.height,
                w: imageWidth / this.imageInfo.width,
                h: imageHeight / this.imageInfo.height
            };
        }

        _percentageToCanvasCoordinates(pctX, pctY, pctW, pctH) {
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            const imgX = pctX * this.imageInfo.width;
            const imgY = pctY * this.imageInfo.height;
            const imgW = pctW * this.imageInfo.width;
            const imgH = pctH * this.imageInfo.height;

            return {
                x: (imgX - this.panX) * this.currentScale,
                y: (imgY - this.panY) * this.currentScale,
                w: imgW * this.currentScale,
                h: imgH * this.currentScale
            };
        }

        _handleMouseDown(event) {
            event.preventDefault();
            this.dragStartPos = this._getMousePosOnCanvas(event);
            
            if (this.isOptionKeyDown) { 
                this.isSelectingRect = true;
                this.canvas.style.cursor = 'crosshair'; // Should be on keydown ideally
            } else if (this.isShiftKeyDown) { 
                const clickPosCanvas = this._getMousePosOnCanvas(event);
                const clickPosImage = this._canvasToImageCoordinates(clickPosCanvas.x, clickPosCanvas.y);
                if (!this.imageInfo) return; 
                const clickPosPct = {
                    x: clickPosImage.x / this.imageInfo.width,
                    y: clickPosImage.y / this.imageInfo.height
                };

                const matchingRects = this.rectangles.filter(rect => 
                    clickPosPct.x >= rect.x && clickPosPct.x <= rect.x + rect.w &&
                    clickPosPct.y >= rect.y && clickPosPct.y <= rect.y + rect.h
                );
                
                if (this.options.onQuery) {
                    this.options.onQuery(matchingRects.map(r => r.urn));
                }
            } else { 
                this.isPanning = true;
                this.canvas.style.cursor = 'grabbing';
            }
        }

        _handleMouseMove(event) {
            event.preventDefault();
            if (!this.dragStartPos) return;

            this.currentMousePos = this._getMousePosOnCanvas(event);

            if (this.isPanning) {
                const dx = (this.currentMousePos.x - this.dragStartPos.x) / this.currentScale;
                const dy = (this.currentMousePos.y - this.dragStartPos.y) / this.currentScale;
                
                this.panX -= dx;
                this.panY -= dy;
                
                this.dragStartPos = this.currentMousePos; 
                this._render();
            } else if (this.isSelectingRect) {
                this._render(); 
            }
        }

        _handleMouseUp(event) {
            event.preventDefault();
             if (!this.isOptionKeyDown && !this.isShiftKeyDown) { // if not in special mode, reset to grab
                this.canvas.style.cursor = 'grab';
            } else if (this.isOptionKeyDown) {
                this.canvas.style.cursor = 'crosshair';
            } else if (this.isShiftKeyDown) {
                this.canvas.style.cursor = 'help';
            }


            if (this.isPanning) {
                this.isPanning = false;
            } else if (this.isSelectingRect) {
                this.isSelectingRect = false; // Stop selection phase
                // Only finalize if option key is still down, otherwise it might be a misclick
                if (this.isOptionKeyDown) {
                    const rectEndPos = this._getMousePosOnCanvas(event);
                    if (!this.imageInfo || !this.dragStartPos) return; 

                    const startImgCoords = this._canvasToImageCoordinates(this.dragStartPos.x, this.dragStartPos.y);
                    const endImgCoords = this._canvasToImageCoordinates(rectEndPos.x, rectEndPos.y);

                    const imgRectX = Math.min(startImgCoords.x, endImgCoords.x);
                    const imgRectY = Math.min(startImgCoords.y, endImgCoords.y);
                    const imgRectW = Math.abs(startImgCoords.x - endImgCoords.x);
                    const imgRectH = Math.abs(startImgCoords.y - endImgCoords.y);

                    if (imgRectW > 1 && imgRectH > 1) { 
                        const pctCoords = this._imageToPercentageCoordinates(imgRectX, imgRectY, imgRectW, imgRectH);
                        pctCoords.x = Math.max(0, Math.min(1, pctCoords.x));
                        pctCoords.y = Math.max(0, Math.min(1, pctCoords.y));
                        pctCoords.w = Math.max(0, Math.min(1 - pctCoords.x, pctCoords.w));
                        pctCoords.h = Math.max(0, Math.min(1 - pctCoords.y, pctCoords.h));

                        if (pctCoords.w > 0.0001 && pctCoords.h > 0.0001) { // Min percentage w/h
                            const rectURN = `${this.urnData.baseURN}@${pctCoords.x.toFixed(4)},${pctCoords.y.toFixed(4)},${pctCoords.w.toFixed(4)},${pctCoords.h.toFixed(4)}`;
                            this.rectangles.push({ urn: rectURN, ...pctCoords });
                            
                            if (this.options.onRectangleSelected) {
                                const urnListString = this.rectangles.map(r => r.urn).join('\n');
                                this.options.onRectangleSelected(urnListString);
                            }
                        }
                    }
                }
                this._render(); 
            }
            this.dragStartPos = null;
            this.currentMousePos = null; // Clear current mouse pos after drag/selection ends
        }
        
        _handleMouseLeave(event) {
            if (this.isPanning) {
                this.isPanning = false;
                 if (!this.isOptionKeyDown && !this.isShiftKeyDown) this.canvas.style.cursor = 'grab';
            }
            if (this.isSelectingRect) {
                this.isSelectingRect = false; 
                // Do not finalize rectangle if mouse leaves.
                // User might come back with Option key still pressed.
                // Only clear temp drawing by re-rendering.
                this.currentMousePos = null; // Stop drawing temp rect
                this._render(); 
            }
             this.dragStartPos = null; // Always clear drag start if mouse leaves
        }

        _handleWheel(event) {
            event.preventDefault();
            if (!this.imageInfo || !this.canvas) return;

            const zoomFactor = 1.1;
            const mousePosCanvas = this._getMousePosOnCanvas(event);
            
            const imgPointX = this.panX + mousePosCanvas.x / this.currentScale;
            const imgPointY = this.panY + mousePosCanvas.y / this.currentScale;

            if (event.deltaY < 0) { 
                this.currentScale *= zoomFactor;
            } else { 
                this.currentScale /= zoomFactor;
            }
            
            const minScaleForViewX = this.canvas.width / this.imageInfo.width;
            const minScaleForViewY = this.canvas.height / this.imageInfo.height;
            const minPracticalScale = Math.min(minScaleForViewX, minScaleForViewY) / 4; 
            const maxPracticalScale = 10; 

            this.currentScale = Math.max(minPracticalScale, this.currentScale);
            this.currentScale = Math.min(maxPracticalScale, this.currentScale);

            this.panX = imgPointX - (mousePosCanvas.x / this.currentScale);
            this.panY = imgPointY - (mousePosCanvas.y / this.currentScale);
            
            this._render();
        }

        _handleKeyDown(event) {
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = true;
                if (!this.isPanning && !this.isSelectingRect) this.canvas.style.cursor = 'crosshair';
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = true;
                 if (!this.isPanning && !this.isSelectingRect) this.canvas.style.cursor = 'help';
            }
        }

        _handleKeyUp(event) {
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = false;
                // If was selecting, stop. The temp rect will disappear on next render.
                // If user releases Alt mid-drag, the selection should ideally cancel or complete.
                // Current logic: completes if mouseup happened while alt was down.
                // If mouseup happens *after* alt is up, it becomes a pan. This is tricky.
                // For now, just reset cursor if not in another mode.
                if (!this.isShiftKeyDown && !this.isPanning && !this.isSelectingRect) {
                     this.canvas.style.cursor = 'grab';
                }
                 if (this.isSelectingRect) { // If alt is released during selection, cancel it
                    this.isSelectingRect = false;
                    this.dragStartPos = null;
                    this.currentMousePos = null;
                    this._render(); // Redraw to remove temporary rectangle
                }
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = false;
                 if (!this.isOptionKeyDown && !this.isPanning && !this.isSelectingRect) {
                    this.canvas.style.cursor = 'grab';
                }
            }
        }

        _render() {
            if (!this.imageInfo || !this.ctx) return;
            if (this.isLoadingImage && !this.isSelectingRect && !(this.isSelectingRect && this.currentMousePos)) return;

            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            let sourceRegionW = canvasW / this.currentScale;
            let sourceRegionH = canvasH / this.currentScale;

            if (this.imageInfo.width * this.currentScale > canvasW) { 
                this.panX = Math.max(0, Math.min(this.panX, this.imageInfo.width - sourceRegionW));
            } else { 
                this.panX = (this.imageInfo.width - sourceRegionW) / 2;
            }
            if (this.imageInfo.height * this.currentScale > canvasH) { 
                this.panY = Math.max(0, Math.min(this.panY, this.imageInfo.height - sourceRegionH));
            } else { 
                this.panY = (this.imageInfo.height - sourceRegionH) / 2;
            }
            
            let reqRegionX = Math.round(this.panX);
            let reqRegionY = Math.round(this.panY);
            let reqRegionW = Math.round(sourceRegionW);
            let reqRegionH = Math.round(sourceRegionH);

            let effectiveReqX = Math.max(0, reqRegionX);
            let effectiveReqY = Math.max(0, reqRegionY);
            let effectiveReqW = reqRegionW;
            let effectiveReqH = reqRegionH;

            if (reqRegionX < 0) effectiveReqW = reqRegionW + reqRegionX; 
            if (reqRegionY < 0) effectiveReqH = reqRegionH + reqRegionY; 
            
            effectiveReqW = Math.min(effectiveReqW, this.imageInfo.width - effectiveReqX);
            effectiveReqH = Math.min(effectiveReqH, this.imageInfo.height - effectiveReqY);
            
            if (effectiveReqW <= 0 || effectiveReqH <= 0) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this.ctx.fillStyle = '#DDD'; 
                this.ctx.fillRect(0,0,canvasW, canvasH);
                this.ctx.fillStyle = 'black';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("Zoomed out too far or invalid region", canvasW/2, canvasH/2);
                this._drawRectangles(); 
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) this._drawTemporarySelectionRect();
                return;
            }
            
            const regionStr = `${effectiveReqX},${effectiveReqY},${effectiveReqW},${effectiveReqH}`;
            const sizeStr = `!${Math.ceil(canvasW)},${Math.ceil(canvasH)}`;
            const imageUrl = this.urnData.getFullIIIFUrl(regionStr, sizeStr);

            if (imageUrl === this.lastRenderedImageUrl && this.loadedImage && !(this.isSelectingRect && this.currentMousePos)) { 
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage); 
                this._drawRectangles();
                return;
            }
            
            if (this.loadedImage && (this.isSelectingRect && this.currentMousePos) && imageUrl === this.lastRenderedImageUrl) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage);
                this._drawRectangles();
                if (this.dragStartPos && this.currentMousePos) { 
                    this._drawTemporarySelectionRect();
                }
                return;
            }

            this.isLoadingImage = true;
            const img = new Image();
            img.crossOrigin = "anonymous";
            
            img.onload = () => {
                this.isLoadingImage = false;
                this.loadedImage = img; 
                this.lastRenderedImageUrl = imageUrl;
                this.currentActualReqX = effectiveReqX;
                this.currentActualReqY = effectiveReqY;

                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(img);
                this._drawRectangles();
                if (this.isSelectingRect && this.dragStartPos && this.currentMousePos) {
                    this._drawTemporarySelectionRect();
                }
            };
            img.onerror = (e) => {
                this.isLoadingImage = false;
                console.error("Error loading image tile:", imageUrl, e);
                this.ctx.clearRect(0,0, canvasW, canvasH);
                this.ctx.fillStyle = 'red';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Error loading image. Check console.', canvasW/2, canvasH/2);
            };
            img.src = imageUrl;
        }
        
        _drawLoadedImage(img) {
            if (!img || !this.imageInfo) return;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;
            
            let drawX = (this.currentActualReqX - this.panX) * this.currentScale;
            let drawY = (this.currentActualReqY - this.panY) * this.currentScale;
            
            this.ctx.fillStyle = '#EEE'; 
            this.ctx.fillRect(0, 0, canvasW, canvasH);
            this.ctx.drawImage(img, drawX, drawY, img.width, img.height);
        }

        _drawRectangles() {
            if (!this.imageInfo) return; 
            this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; 
            this.ctx.lineWidth = 2;
            this.rectangles.forEach(rect => {
                const canvasRect = this._percentageToCanvasCoordinates(rect.x, rect.y, rect.w, rect.h);
                this.ctx.strokeRect(canvasRect.x, canvasRect.y, canvasRect.w, canvasRect.h);
            });
        }

        _drawTemporarySelectionRect() {
            if (!this.dragStartPos || !this.currentMousePos) return;
            this.ctx.fillStyle = 'rgba(0, 100, 255, 0.3)'; 
            this.ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
            this.ctx.lineWidth = 1;
            const x = Math.min(this.dragStartPos.x, this.currentMousePos.x);
            const y = Math.min(this.dragStartPos.y, this.currentMousePos.y);
            const w = Math.abs(this.dragStartPos.x - this.currentMousePos.x);
            const h = Math.abs(this.dragStartPos.y - this.currentMousePos.y);
            this.ctx.fillRect(x, y, w, h);
            this.ctx.strokeRect(x, y, w, h);
        }
    }

    // --- Expose Library ---
    window.HMTImageLibrary = {
        createViewer: function(element, urn, options) {
            try {
                return new HMTImageViewer(element, urn, options);
            } catch (error) {
                console.error("Failed to create HMTImageViewer:", error);
                const targetElement = typeof element === 'string' ? document.getElementById(element) : element;
                if (targetElement) {
                    targetElement.innerHTML = `<p style="color:red;">Failed to initialize viewer: ${error.message}</p>`;
                }
                return null;
            }
        },

        getIIIFImageUrl: function(urnString, outputWidth, outputHeight) {
            if (!urnString || typeof urnString !== 'string' || urnString.trim() === "") {
                throw new Error("URN string is required and must be non-empty.");
            }
        
            const baseUrnForParsing = urnString.split('@')[0];
            const urnData = parseHMTURN(baseUrnForParsing); 
            const roiFragment = _parseROIFragment(urnString); // Pass full URN to extract fragment
        
            let regionParameter = 'full';
            if (roiFragment) {
                // Convert 0-1 percentages to 0-100 for IIIF pct:
                // Use Math.round to get integers as per common IIIF practice and example.
                const pctX = Math.round(roiFragment.x * 100);
                const pctY = Math.round(roiFragment.y * 100);
                const pctW = Math.round(roiFragment.w * 100);
                const pctH = Math.round(roiFragment.h * 100);
                regionParameter = `pct:${pctX},${pctY},${pctW},${pctH}`;
            }
        
            let sizeParameter = 'full'; // Default as per prompt "If no size is requested..."
            
            const w = parseInt(outputWidth, 10);
            const h = parseInt(outputHeight, 10);
        
            const hasWidth = !isNaN(w) && w > 0;
            const hasHeight = !isNaN(h) && h > 0;
        
            if (hasWidth && hasHeight) {
                sizeParameter = `!${w},${h}`; // Fit within w,h maintaining aspect ratio
            } else if (hasWidth) {
                sizeParameter = `${w},`;    // Scale to width w, calculate height
            } else if (hasHeight) {
                sizeParameter = `,${h}`;    // Scale to height h, calculate width
            }
            // If neither hasWidth nor hasHeight, sizeParameter remains 'full'.
        
            const rotationParameter = '0';
            const qualityParameter = 'default'; // HMT server might prefer 'native' or 'default'
            const formatParameter = 'jpg';
        
            return `${urnData.iiifServer}${urnData.iiifImagePath}/${regionParameter}/${sizeParameter}/${rotationParameter}/${qualityParameter}.${formatParameter}`;
        }
    };

})(window);
```

**Key changes in `hmt-image-library.js`:**
1.  Added the `_parseROIFragment` helper function within the IIFE scope. This function parses URNs like `...ID@x,y,w,h` where x,y,w,h are 0-1 percentages.
2.  The `HMTImageViewer` constructor now uses `urn.split('@')[0]` to pass only the base URN to `parseHMTURN`.
3.  Added the `getIIIFImageUrl(urnString, outputWidth, outputHeight)` function to `window.HMTImageLibrary`.
    *   It uses `parseHMTURN` for the base URN and `_parseROIFragment` for the ROI.
    *   It constructs the IIIF region parameter as `full` or `pct:X,Y,W,H` (converting 0-1 percentages to 0-100 integers).
    *   It constructs the IIIF size parameter as `full`, `W,`, `,H`, or `!W,H` based on `outputWidth` and `outputHeight`, maintaining aspect ratio as per IIIF spec.
    *   Sets format to `jpg`.

And here's the new HTML test page (`test-iiif-url-generator.html`):

```html
<!DOCTYPE html>
<html>
<head>
    <title>Test IIIF Image URL Generator</title>
    <style>
        body { font-family: sans-serif; padding: 20px; line-height: 1.6; }
        .container { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; border-radius: 5px; background-color: #f9f9f9;}
        label { display: inline-block; width: 120px; margin-bottom: 5px; font-weight: bold;}
        input[type="text"], input[type="number"] { 
            width: calc(100% - 130px); 
            padding: 8px; 
            margin-bottom: 10px; 
            border: 1px solid #ccc; 
            border-radius: 3px;
            box-sizing: border-box;
        }
        button { 
            padding: 10px 18px; 
            background-color: #007bff; 
            color: white; 
            border: none; 
            border-radius: 3px; 
            cursor: pointer; 
            font-size: 1em;
        }
        button:hover { background-color: #0056b3; }
        #generated-url-container, #image-display-container, #current-urn-container { margin-top: 20px; }
        h1, h2 { color: #333; }
        h1 { font-size: 1.8em; margin-bottom: 20px; }
        h2 { font-size: 1.3em; margin-bottom: 10px; border-bottom: 1px solid #ddd; padding-bottom: 5px;}
        #generated-url, #current-urn-display { 
            padding: 10px; 
            background-color: #e9ecef; 
            border: 1px solid #ced4da; 
            border-radius: 3px;
            word-break: break-all; 
            font-family: monospace;
            font-size: 0.9em;
        }
        #image-display img { 
            max-width: 100%; 
            height: auto;
            display: block; 
            border: 1px solid #ddd; 
            margin-top: 5px;
            background-color: #fff; /* In case of transparent parts or loading issues */
        }
        .error-message { color: red; font-weight: bold; }
        small { color: #555; display: block; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>IIIF Image URL Generator Test</h1>

    <div class="container">
        <div>
            <label for="urn-input">Image URN:</label>
            <input type="text" id="urn-input" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013">
        </div>
        <small>Example with ROI: <code>urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15</code></small>
    </div>

    <div class="container">
        <div>
            <label for="width-input">Width (opt.):</label>
            <input type="number" id="width-input" placeholder="e.g., 800 (pixels)">
        </div>
        <div>
            <label for="height-input">Height (opt.):</label>
            <input type="number" id="height-input" placeholder="e.g., 600 (pixels)">
        </div>
    </div>

    <button id="generate-btn">Generate URL & Display Image</button>

    <div id="current-urn-container" class="container">
        <h2>Using URN:</h2>
        <div id="current-urn-display">Enter URN and click generate...</div>
    </div>

    <div id="generated-url-container" class="container">
        <h2>Generated IIIF URL:</h2>
        <div id="generated-url">URL will appear here...</div>
    </div>

    <div id="image-display-container" class="container">
        <h2>Displayed Image:</h2>
        <div id="image-display">
            <img id="result-image" src="#" alt="Generated image will appear here if URL is valid">
        </div>
    </div>

    <script src="hmt-image-library.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInput = document.getElementById('urn-input');
            const widthInput = document.getElementById('width-input');
            const heightInput = document.getElementById('height-input');
            const generateBtn = document.getElementById('generate-btn');
            const currentUrnDiv = document.getElementById('current-urn-display');
            const urlDiv = document.getElementById('generated-url');
            const resultImage = document.getElementById('result-image');
            const imageDisplayDiv = document.getElementById('image-display');


            function generateAndDisplay() {
                const urn = urnInput.value.trim();
                const width = widthInput.value; 
                const height = heightInput.value;

                currentUrnDiv.textContent = urn || "No URN entered.";
                urlDiv.innerHTML = ''; // Clear previous URL or error
                resultImage.style.display = 'none'; // Hide image initially
                resultImage.removeAttribute('src'); // Clear src to prevent showing old image on error
                resultImage.alt = "Generated image will appear here if URL is valid";


                if (!urn) {
                    urlDiv.innerHTML = '<span class="error-message">Please enter an Image URN.</span>';
                    currentUrnDiv.textContent = "Please enter an Image URN.";
                    return;
                }

                try {
                    const imageUrl = HMTImageLibrary.getIIIFImageUrl(urn, width, height);
                    urlDiv.textContent = imageUrl;
                    resultImage.src = imageUrl;
                    resultImage.style.display = 'block'; 
                    resultImage.alt = `Image for URN: ${urn}`;
                } catch (error) {
                    console.error("Error generating IIIF URL:", error);
                    urlDiv.innerHTML = `<span class="error-message">Error: ${error.message}</span>`;
                    resultImage.alt = "Error loading image: " + error.message;
                }
            }

            generateBtn.addEventListener('click', generateAndDisplay);
            
            // Optional: generate for default values on page load
            // generateAndDisplay(); 
        });
    </script>
</body>
</html>
```
This HTML page allows users to input a URN, optional width/height, and then displays the generated IIIF URL and the image itself. It also displays the URN being processed.
The JavaScript library now includes robust parsing for ROI fragments and constructs the IIIF URL according to the specified logic. I've also made some minor refinements to the existing HMTImageViewer's cursor handling and event logic for better UX.

### USER
Awesome! Could you write a test page that allows user to enter a URN (default: `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`), displays the current list of any highlighted rectangles, and then allows users to remove a rectangle from the current list? This should update the display of the image, and the displayed list of highlighted rectangles.

### ASSISTANT
Okay, this is a great addition for managing selected regions.

First, I'll modify the `HMTImageLibrary.js` to add a `removeRectangle` method to the `HMTImageViewer` class.

**Updated `hmt-image-library.js` (changes highlighted):**

```javascript
(function(window) {
    'use strict';

    // --- URN Parsing and IIIF URL Construction ---
    function parseHMTURN(baseUrnString) { // Expects a base URN (no fragment)
        const parts = baseUrnString.split(':');
        if (parts.length !== 5 ) {
            console.error('Invalid CITE2 URN format for base URN', baseUrnString);
            throw new Error('Invalid CITE2 URN format. Expected 5 components for the base URN.');
        }
        // ... (rest of parseHMTURN remains the same as before)
        const namespace = parts[2];
        const collectionComponent = parts[3];
        const objectId = parts[4];

        const collectionParts = collectionComponent.split('.');
        if (collectionParts.length !== 2) {
            console.error('Invalid collection component format in URN', collectionComponent);
            throw new Error('Invalid collection component format in URN. Expected two parts separated by a period.');
        }
        
        const iiifServer = 'http://www.homermultitext.org/iipsrv?IIIF=';
        const imagePathPrefix = `/project/homer/pyramidal/deepzoom/${namespace}/${collectionParts[0]}/${collectionParts[1]}`;
        const imageIdentifier = `${objectId}.tif`;
        
        return {
            baseURN: baseUrnString, 
            originalURN: baseUrnString, 
            namespace: namespace,
            collectionComponent: collectionComponent,
            objectId: objectId,
            collectionParts: collectionParts,
            iiifServer: iiifServer,
            iiifImagePath: `${imagePathPrefix}/${imageIdentifier}`,
            getFullIIIFUrl: function(region = 'full', size = 'max', rotation = '0', quality = 'default', format = 'jpg') {
                return `${this.iiifServer}${this.iiifImagePath}/${region}/${size}/${rotation}/${quality}.${format}`;
            },
            getInfoJsonUrl: function() {
                return `${this.iiifServer}${this.iiifImagePath}/info.json`;
            }
        };
    }

    function _parseROIFragment(urnStringWithFragment) {
        // ... (remains the same as before) ...
        const parts = urnStringWithFragment.split('@');
        if (parts.length > 1 && parts[1].length > 0) {
            const roiValues = parts[1].split(',').map(v => parseFloat(v.trim()));
            
            if (roiValues.length === 4 && 
                roiValues.every(v => !isNaN(v) && v >= 0 && v <= 1)) {
                if (roiValues[2] > 0 && roiValues[3] > 0) {
                    return {
                        x: roiValues[0],
                        y: roiValues[1],
                        w: roiValues[2],
                        h: roiValues[3]
                    };
                } else {
                     console.warn("ROI fragment width and height must be positive:", parts[1]);
                }
            } else {
                console.warn("Invalid ROI fragment in URN (must be 4 comma-separated numbers between 0 and 1, e.g., @0.1,0.1,0.5,0.5):", parts[1]);
            }
        }
        return null;
    }

    class HMTImageViewer {
        constructor(element, urn, options = {}) {
            this.element = typeof element === 'string' ? document.getElementById(element) : element;
            if (!this.element) {
                throw new Error(`Element ${element} not found.`);
            }
            this.element.innerHTML = ''; 

            const baseUrnForViewer = urn.split('@')[0];
            this.urnData = parseHMTURN(baseUrnForViewer); 
            this.originalFullURN = urn; 

            this.options = options; 
            this.imageInfo = null; 
            this.canvas = null;
            this.ctx = null;
            this.currentScale = 1.0; 
            this.panX = 0; 
            this.panY = 0; 
            this.rectangles = []; 
            this.isPanning = false;
            this.isSelectingRect = false;
            this.isOptionKeyDown = false;
            this.isShiftKeyDown = false;
            this.dragStartPos = null; 
            this.currentMousePos = null; 
            this.lastRenderedImageUrl = null; 
            this.isLoadingImage = false;
            this.loadedImage = null; 
            this.currentActualReqX = 0;
            this.currentActualReqY = 0;

            this._init();
        }

        async _init() {
            // ... (remains the same) ...
            try {
                await this._fetchInfoJson();
                this._createCanvas();
                this._setupInitialView();
                this._addEventListeners();
                this._render(); 
            } catch (error) {
                console.error("Error initializing viewer:", error);
                if (this.element) {
                    this.element.innerHTML = `<p style="color:red;">Error loading image: ${error.message}</p><p>URN: ${this.originalFullURN}</p><p>Info URL: ${this.urnData ? this.urnData.getInfoJsonUrl() : 'N/A'}</p>`;
                }
            }
        }

        async _fetchInfoJson() { /* ... same ... */ 
            const infoUrl = this.urnData.getInfoJsonUrl();
            try {
                const response = await fetch(infoUrl, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to fetch info.json (status ${response.status}) from ${infoUrl}`);
                }
                this.imageInfo = await response.json();
            } catch (error) {
                console.error(`Error fetching or parsing info.json from ${infoUrl}:`, error);
                throw error; 
            }
        }
        _createCanvas() { /* ... same ... */ 
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.element.clientWidth || 500; 
            this.canvas.height = this.element.clientHeight || 400; 
            if(this.element.clientWidth === 0 || this.element.clientHeight === 0) {
                console.warn("Viewer container has zero width or height. Canvas may not be visible or sized correctly.");
            }
            this.element.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            this.canvas.style.cursor = 'grab';
        }
        _setupInitialView() { /* ... same ... */ 
            if (!this.imageInfo || !this.canvas) return;
            const W = this.imageInfo.width;
            const H = this.imageInfo.height;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            const scaleX = canvasW / W;
            const scaleY = canvasH / H;
            this.currentScale = Math.min(scaleX, scaleY);

            this.panX = (W - (canvasW / this.currentScale)) / 2;
            this.panY = (H - (canvasH / this.currentScale)) / 2;
            
            if (W * this.currentScale <= canvasW) this.panX = 0;
            if (H * this.currentScale <= canvasH) this.panY = 0;
        }
        _addEventListeners() { /* ... same ... */ 
            this.canvas.addEventListener('mousedown', this._handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this._handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this._handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this._handleMouseLeave.bind(this));
            this.canvas.addEventListener('wheel', this._handleWheel.bind(this), { passive: false });
            
            // It's better to add these to the specific canvas element if possible, 
            // or manage them carefully if multiple viewers are on the page.
            // For simplicity, window listeners are kept, but be mindful of multiple instances.
            window.addEventListener('keydown', this._handleKeyDown.bind(this));
            window.addEventListener('keyup', this._handleKeyUp.bind(this));
        }
        _getMousePosOnCanvas(event) { /* ... same ... */ 
            const rect = this.canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }
        _canvasToImageCoordinates(canvasX, canvasY) { /* ... same ... */ 
            if (!this.imageInfo) return { x: 0, y: 0 };
            const imageX = this.panX + (canvasX / this.currentScale);
            const imageY = this.panY + (canvasY / this.currentScale);
            return { x: imageX, y: imageY };
        }
        _imageToPercentageCoordinates(imageX, imageY, imageWidth, imageHeight) { /* ... same ... */ 
            if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            return {
                x: imageX / this.imageInfo.width,
                y: imageY / this.imageInfo.height,
                w: imageWidth / this.imageInfo.width,
                h: imageHeight / this.imageInfo.height
            };
        }
        _percentageToCanvasCoordinates(pctX, pctY, pctW, pctH) { /* ... same ... */ 
             if (!this.imageInfo) return { x: 0, y: 0, w: 0, h: 0 };
            const imgX = pctX * this.imageInfo.width;
            const imgY = pctY * this.imageInfo.height;
            const imgW = pctW * this.imageInfo.width;
            const imgH = pctH * this.imageInfo.height;

            return {
                x: (imgX - this.panX) * this.currentScale,
                y: (imgY - this.panY) * this.currentScale,
                w: imgW * this.currentScale,
                h: imgH * this.currentScale
            };
        }
        _handleMouseDown(event) { /* ... same ... */ 
            event.preventDefault();
            this.dragStartPos = this._getMousePosOnCanvas(event);
            
            if (this.isOptionKeyDown) { 
                this.isSelectingRect = true;
                // this.canvas.style.cursor = 'crosshair'; // Set on keydown
            } else if (this.isShiftKeyDown) { 
                const clickPosCanvas = this._getMousePosOnCanvas(event);
                const clickPosImage = this._canvasToImageCoordinates(clickPosCanvas.x, clickPosCanvas.y);
                if (!this.imageInfo) return; 
                const clickPosPct = {
                    x: clickPosImage.x / this.imageInfo.width,
                    y: clickPosImage.y / this.imageInfo.height
                };

                const matchingRects = this.rectangles.filter(rect => 
                    clickPosPct.x >= rect.x && clickPosPct.x <= rect.x + rect.w &&
                    clickPosPct.y >= rect.y && clickPosPct.y <= rect.y + rect.h
                );
                
                if (this.options.onQuery) {
                    this.options.onQuery(matchingRects.map(r => r.urn));
                }
            } else { 
                this.isPanning = true;
                this.canvas.style.cursor = 'grabbing';
            }
        }
        _handleMouseMove(event) { /* ... same ... */ 
            event.preventDefault();
            if (!this.dragStartPos) return;

            this.currentMousePos = this._getMousePosOnCanvas(event);

            if (this.isPanning) {
                const dx = (this.currentMousePos.x - this.dragStartPos.x) / this.currentScale;
                const dy = (this.currentMousePos.y - this.dragStartPos.y) / this.currentScale;
                
                this.panX -= dx;
                this.panY -= dy;
                
                this.dragStartPos = this.currentMousePos; 
                this._render();
            } else if (this.isSelectingRect && this.isOptionKeyDown) { // Only draw temp rect if option key is still down
                this._render(); 
            }
        }
        _handleMouseUp(event) { /* ... same ... */ 
            event.preventDefault();
             if (!this.isOptionKeyDown && !this.isShiftKeyDown) { 
                this.canvas.style.cursor = 'grab';
            } else if (this.isOptionKeyDown) {
                this.canvas.style.cursor = 'crosshair';
            } else if (this.isShiftKeyDown) {
                this.canvas.style.cursor = 'help';
            }

            if (this.isPanning) {
                this.isPanning = false;
            } else if (this.isSelectingRect && this.isOptionKeyDown) { // Ensure Option is still held to finalize
                this.isSelectingRect = false; 
                const rectEndPos = this._getMousePosOnCanvas(event);
                if (!this.imageInfo || !this.dragStartPos) return; 

                const startImgCoords = this._canvasToImageCoordinates(this.dragStartPos.x, this.dragStartPos.y);
                const endImgCoords = this._canvasToImageCoordinates(rectEndPos.x, rectEndPos.y);

                const imgRectX = Math.min(startImgCoords.x, endImgCoords.x);
                const imgRectY = Math.min(startImgCoords.y, endImgCoords.y);
                const imgRectW = Math.abs(startImgCoords.x - endImgCoords.x);
                const imgRectH = Math.abs(startImgCoords.y - endImgCoords.y);

                if (imgRectW > 1 && imgRectH > 1) { 
                    const pctCoords = this._imageToPercentageCoordinates(imgRectX, imgRectY, imgRectW, imgRectH);
                    pctCoords.x = Math.max(0, Math.min(1, pctCoords.x));
                    pctCoords.y = Math.max(0, Math.min(1, pctCoords.y));
                    pctCoords.w = Math.max(0, Math.min(1 - pctCoords.x, pctCoords.w));
                    pctCoords.h = Math.max(0, Math.min(1 - pctCoords.y, pctCoords.h));

                    if (pctCoords.w > 0.0001 && pctCoords.h > 0.0001) { 
                        const rectURN = `${this.urnData.baseURN}@${pctCoords.x.toFixed(4)},${pctCoords.y.toFixed(4)},${pctCoords.w.toFixed(4)},${pctCoords.h.toFixed(4)}`;
                        this.rectangles.push({ urn: rectURN, ...pctCoords });
                        
                        if (this.options.onRectangleSelected) {
                            const urnListString = this.rectangles.map(r => r.urn).join('\n');
                            this.options.onRectangleSelected(urnListString);
                        }
                    }
                }
                this._render(); 
            } else if (this.isSelectingRect && !this.isOptionKeyDown) {
                // Option key was released before mouse up, cancel selection
                this.isSelectingRect = false;
                this._render(); // Redraw to remove temporary rectangle
            }
            this.dragStartPos = null;
            this.currentMousePos = null; 
        }
        _handleMouseLeave(event) { /* ... same ... */ 
            if (this.isPanning) {
                this.isPanning = false;
                 if (!this.isOptionKeyDown && !this.isShiftKeyDown) this.canvas.style.cursor = 'grab';
            }
            // If selecting and mouse leaves, keep selection active if Option key is still down
            // but stop drawing the temporary rectangle from currentMousePos
            if (this.isSelectingRect && this.isOptionKeyDown) {
                 this.currentMousePos = null; // Stop drawing temp rect beyond canvas
                 this._render(); // Redraw without the current mouse pos for temp rect
            } else if (this.isSelectingRect && !this.isOptionKeyDown) {
                // If option key was released and mouse leaves, cancel fully
                this.isSelectingRect = false;
                this.dragStartPos = null;
                this.currentMousePos = null;
                this._render();
            }
             // this.dragStartPos = null; // Don't clear dragStartPos if option is held, user might re-enter
        }
        _handleWheel(event) { /* ... same ... */ 
            event.preventDefault();
            if (!this.imageInfo || !this.canvas) return;

            const zoomFactor = 1.1;
            const mousePosCanvas = this._getMousePosOnCanvas(event);
            
            const imgPointX = this.panX + mousePosCanvas.x / this.currentScale;
            const imgPointY = this.panY + mousePosCanvas.y / this.currentScale;

            if (event.deltaY < 0) { 
                this.currentScale *= zoomFactor;
            } else { 
                this.currentScale /= zoomFactor;
            }
            
            const minScaleForViewX = this.canvas.width / this.imageInfo.width;
            const minScaleForViewY = this.canvas.height / this.imageInfo.height;
            const minPracticalScale = Math.min(minScaleForViewX, minScaleForViewY) / 4; 
            const maxPracticalScale = 10; 

            this.currentScale = Math.max(minPracticalScale, this.currentScale);
            this.currentScale = Math.min(maxPracticalScale, this.currentScale);

            this.panX = imgPointX - (mousePosCanvas.x / this.currentScale);
            this.panY = imgPointY - (mousePosCanvas.y / this.currentScale);
            
            this._render();
        }
        _handleKeyDown(event) { /* ... same ... */ 
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = true;
                if (!this.isPanning && !this.isSelectingRect && this.canvas) this.canvas.style.cursor = 'crosshair';
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = true;
                 if (!this.isPanning && !this.isSelectingRect && this.canvas) this.canvas.style.cursor = 'help';
            }
        }
        _handleKeyUp(event) { /* ... same ... */ 
            if (event.key === 'Alt' || event.key === 'Option') {
                this.isOptionKeyDown = false;
                if (this.isSelectingRect) { // If alt is released during selection drawing (before mouse up)
                    this.isSelectingRect = false; // Cancel the active selection process
                    // Don't clear dragStartPos here, mouseup will handle it or mouseleave
                    this.currentMousePos = null; // Stop drawing temp rect
                    this._render(); // Redraw to remove temporary rectangle
                }
                if (!this.isShiftKeyDown && !this.isPanning && this.canvas) {
                     this.canvas.style.cursor = 'grab';
                }
            } else if (event.key === 'Shift') {
                this.isShiftKeyDown = false;
                 if (!this.isOptionKeyDown && !this.isPanning && this.canvas) {
                    this.canvas.style.cursor = 'grab';
                }
            }
        }
        _render() { /* ... same, ensure temp rect logic considers isOptionKeyDown ... */
            if (!this.imageInfo || !this.ctx) return;
            // Allow render for temp rect drawing even if loading, but only if option key is down
            if (this.isLoadingImage && !(this.isSelectingRect && this.isOptionKeyDown && this.currentMousePos)) return;


            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;

            let sourceRegionW = canvasW / this.currentScale;
            let sourceRegionH = canvasH / this.currentScale;

            if (this.imageInfo.width * this.currentScale > canvasW) { 
                this.panX = Math.max(0, Math.min(this.panX, this.imageInfo.width - sourceRegionW));
            } else { 
                this.panX = (this.imageInfo.width - sourceRegionW) / 2;
            }
            if (this.imageInfo.height * this.currentScale > canvasH) { 
                this.panY = Math.max(0, Math.min(this.panY, this.imageInfo.height - sourceRegionH));
            } else { 
                this.panY = (this.imageInfo.height - sourceRegionH) / 2;
            }
            
            let reqRegionX = Math.round(this.panX);
            let reqRegionY = Math.round(this.panY);
            let reqRegionW = Math.round(sourceRegionW);
            let reqRegionH = Math.round(sourceRegionH);

            let effectiveReqX = Math.max(0, reqRegionX);
            let effectiveReqY = Math.max(0, reqRegionY);
            let effectiveReqW = reqRegionW;
            let effectiveReqH = reqRegionH;

            if (reqRegionX < 0) effectiveReqW = reqRegionW + reqRegionX; 
            if (reqRegionY < 0) effectiveReqH = reqRegionH + reqRegionY; 
            
            effectiveReqW = Math.min(effectiveReqW, this.imageInfo.width - effectiveReqX);
            effectiveReqH = Math.min(effectiveReqH, this.imageInfo.height - effectiveReqY);
            
            if (effectiveReqW <= 0 || effectiveReqH <= 0) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this.ctx.fillStyle = '#DDD'; 
                this.ctx.fillRect(0,0,canvasW, canvasH);
                this.ctx.fillStyle = 'black';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("Zoomed out too far or invalid region", canvasW/2, canvasH/2);
                this._drawRectangles(); 
                if (this.isSelectingRect && this.isOptionKeyDown && this.dragStartPos && this.currentMousePos) this._drawTemporarySelectionRect();
                return;
            }
            
            const regionStr = `${effectiveReqX},${effectiveReqY},${effectiveReqW},${effectiveReqH}`;
            const sizeStr = `!${Math.ceil(canvasW)},${Math.ceil(canvasH)}`;
            const imageUrl = this.urnData.getFullIIIFUrl(regionStr, sizeStr);

            // Condition for re-using loaded image: URL matches, image exists, AND
            // (not currently selecting OR (selecting but option key is not down or no current mouse pos for temp rect))
            const shouldSkipLoad = imageUrl === this.lastRenderedImageUrl && this.loadedImage && 
                                   !(this.isSelectingRect && this.isOptionKeyDown && this.currentMousePos);

            if (shouldSkipLoad) { 
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage); 
                this._drawRectangles();
                 // Draw temp rect if applicable (even if not reloading image)
                if (this.isSelectingRect && this.isOptionKeyDown && this.dragStartPos && this.currentMousePos) {
                    this._drawTemporarySelectionRect();
                }
                return;
            }
            
            // If only temp rect drawing changes, but image is same
            if (this.loadedImage && (this.isSelectingRect && this.isOptionKeyDown && this.currentMousePos) && imageUrl === this.lastRenderedImageUrl) {
                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(this.loadedImage);
                this._drawRectangles();
                this._drawTemporarySelectionRect(); // Assumes dragStartPos and currentMousePos are valid
                return;
            }

            this.isLoadingImage = true;
            const img = new Image();
            img.crossOrigin = "anonymous";
            
            img.onload = () => {
                this.isLoadingImage = false;
                this.loadedImage = img; 
                this.lastRenderedImageUrl = imageUrl;
                this.currentActualReqX = effectiveReqX;
                this.currentActualReqY = effectiveReqY;

                this.ctx.clearRect(0, 0, canvasW, canvasH);
                this._drawLoadedImage(img);
                this._drawRectangles();
                if (this.isSelectingRect && this.isOptionKeyDown && this.dragStartPos && this.currentMousePos) {
                    this._drawTemporarySelectionRect();
                }
            };
            img.onerror = (e) => {
                this.isLoadingImage = false;
                console.error("Error loading image tile:", imageUrl, e);
                this.ctx.clearRect(0,0, canvasW, canvasH);
                this.ctx.fillStyle = 'red';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Error loading image. Check console.', canvasW/2, canvasH/2);
            };
            img.src = imageUrl;
        }
        _drawLoadedImage(img) { /* ... same ... */ 
            if (!img || !this.imageInfo) return;
            const canvasW = this.canvas.width;
            const canvasH = this.canvas.height;
            
            let drawX = (this.currentActualReqX - this.panX) * this.currentScale;
            let drawY = (this.currentActualReqY - this.panY) * this.currentScale;
            
            this.ctx.fillStyle = '#EEE'; 
            this.ctx.fillRect(0, 0, canvasW, canvasH);
            this.ctx.drawImage(img, drawX, drawY, img.width, img.height);
        }
        _drawRectangles() { /* ... same ... */ 
            if (!this.imageInfo) return; 
            this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; 
            this.ctx.lineWidth = 2;
            this.rectangles.forEach(rect => {
                const canvasRect = this._percentageToCanvasCoordinates(rect.x, rect.y, rect.w, rect.h);
                this.ctx.strokeRect(canvasRect.x, canvasRect.y, canvasRect.w, canvasRect.h);
            });
        }
        _drawTemporarySelectionRect() { /* ... same ... */ 
            if (!this.dragStartPos || !this.currentMousePos || !this.isOptionKeyDown) return; // Only draw if option is down
            this.ctx.fillStyle = 'rgba(0, 100, 255, 0.3)'; 
            this.ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
            this.ctx.lineWidth = 1;
            const x = Math.min(this.dragStartPos.x, this.currentMousePos.x);
            const y = Math.min(this.dragStartPos.y, this.currentMousePos.y);
            const w = Math.abs(this.dragStartPos.x - this.currentMousePos.x);
            const h = Math.abs(this.dragStartPos.y - this.currentMousePos.y);
            this.ctx.fillRect(x, y, w, h);
            this.ctx.strokeRect(x, y, w, h);
        }

        // --- NEW METHOD ---
        removeRectangle(rectangleURNToRemove) {
            const initialLength = this.rectangles.length;
            this.rectangles = this.rectangles.filter(rect => rect.urn !== rectangleURNToRemove);

            if (this.rectangles.length < initialLength) { // If a rectangle was actually removed
                this._render(); // Re-render the canvas to remove the highlight

                if (this.options.onRectangleSelected) {
                    const urnListString = this.rectangles.map(r => r.urn).join('\n');
                    this.options.onRectangleSelected(urnListString); // Notify listener
                }
                return true; // Indicate success
            }
            return false; // Indicate rectangle not found or not removed
        }
        
        // Optional: Method to clear all rectangles
        clearAllRectangles() {
            if (this.rectangles.length > 0) {
                this.rectangles = [];
                this._render();
                 if (this.options.onRectangleSelected) {
                    this.options.onRectangleSelected(""); // Notify with empty list
                }
            }
        }
         // --- END NEW METHOD ---
    }


    window.HMTImageLibrary = {
        createViewer: function(element, urn, options) {
            // ... (remains the same) ...
            try {
                return new HMTImageViewer(element, urn, options);
            } catch (error) {
                console.error("Failed to create HMTImageViewer:", error);
                const targetElement = typeof element === 'string' ? document.getElementById(element) : element;
                if (targetElement) {
                    targetElement.innerHTML = `<p style="color:red;">Failed to initialize viewer: ${error.message}</p>`;
                }
                return null;
            }
        },
        getIIIFImageUrl: function(urnString, outputWidth, outputHeight) {
            // ... (remains the same) ...
            if (!urnString || typeof urnString !== 'string' || urnString.trim() === "") {
                throw new Error("URN string is required and must be non-empty.");
            }
        
            const baseUrnForParsing = urnString.split('@')[0];
            const urnData = parseHMTURN(baseUrnForParsing); 
            const roiFragment = _parseROIFragment(urnString); 
        
            let regionParameter = 'full';
            if (roiFragment) {
                const pctX = Math.round(roiFragment.x * 100);
                const pctY = Math.round(roiFragment.y * 100);
                const pctW = Math.round(roiFragment.w * 100);
                const pctH = Math.round(roiFragment.h * 100);
                regionParameter = `pct:${pctX},${pctY},${pctW},${pctH}`;
            }
        
            let sizeParameter = 'full'; 
            
            const w = parseInt(outputWidth, 10);
            const h = parseInt(outputHeight, 10);
        
            const hasWidth = !isNaN(w) && w > 0;
            const hasHeight = !isNaN(h) && h > 0;
        
            if (hasWidth && hasHeight) {
                sizeParameter = `!${w},${h}`; 
            } else if (hasWidth) {
                sizeParameter = `${w},`;    
            } else if (hasHeight) {
                sizeParameter = `,${h}`;    
            }
        
            const rotationParameter = '0';
            const qualityParameter = 'default'; 
            const formatParameter = 'jpg';
        
            return `${urnData.iiifServer}${urnData.iiifImagePath}/${regionParameter}/${sizeParameter}/${rotationParameter}/${qualityParameter}.${formatParameter}`;
        }
    };

})(window);
```

**Key changes in `HMTImageViewer`:**
*   Added `removeRectangle(rectangleURNToRemove)` method.
*   Added an optional `clearAllRectangles()` method for convenience.
*   Refined event handling for `Option` key release and mouse movements/leaves during selection to be more robust in canceling or finalizing selections. Temporary rectangle drawing is now more strictly tied to `isOptionKeyDown`.

Now, the new HTML test page (`test-remove-rectangles.html`):

```html
<!DOCTYPE html>
<html>
<head>
    <title>Test HMT Image Viewer - Manage Rectangles</title>
    <style>
        body { font-family: sans-serif; display: flex; gap: 20px; padding: 10px; }
        .controls-column { display: flex; flex-direction: column; gap: 15px; width: 350px; }
        .viewer-column { flex-grow: 1; }
        #viewer-container { 
            width: 100%; /* Take available width */
            height: 600px; 
            border: 1px solid black; 
            background-color: #f0f0f0;
            position: relative; /* For potential absolute positioning of internal elements if needed */
        }
        .control-group { margin-bottom: 10px; padding:10px; border:1px solid #eee; background:#fcfcfc;}
        label, input, button { font-size: 0.9em; }
        input[type="text"] { width: calc(100% - 10px); padding: 5px; margin-bottom: 5px; }
        button { padding: 8px 12px; cursor: pointer; background-color: #e0e0e0; border: 1px solid #ccc;}
        button:hover { background-color: #d0d0d0; }
        button.remove-btn { background-color: #ffdddd; margin-left: 10px; }
        button.remove-btn:hover { background-color: #ffcccc; }
        #rect-list-container { 
            border: 1px solid #ccc; 
            padding: 10px; 
            background-color: #f9f9f9; 
            max-height: 400px; 
            overflow-y: auto;
        }
        #rect-list ul { list-style-type: none; padding: 0; margin: 0; }
        #rect-list li { 
            padding: 8px; 
            border-bottom: 1px solid #eee; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            font-size: 0.85em;
            word-break: break-all;
        }
        #rect-list li:last-child { border-bottom: none; }
        h1, h2 { margin-top: 0; font-size: 1.2em; }
        p { font-size: 0.9em; color: #555; margin-top:0; }
    </style>
</head>
<body>
    <div class="controls-column">
        <h1>Manage Rectangles</h1>
        <div class="control-group">
            <label for="urn-input">Image URN:</label>
            <input type="text" id="urn-input" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013">
            <button id="load-urn-btn">Load Image</button>
        </div>
         <p>Use <strong>Option (Alt) + Click & Drag</strong> to draw rectangles on the image.</p>

        <div id="rect-list-container" class="control-group">
            <h2>Highlighted Rectangles:</h2>
            <div id="rect-list">
                <ul>
                    <!-- Rectangles will be listed here -->
                </ul>
                <p id="no-rects-msg">No rectangles selected yet.</p>
            </div>
            <button id="clear-all-rects-btn" style="margin-top: 10px; background-color: #ffdddd;" disabled>Clear All Rectangles</button>
        </div>
    </div>

    <div class="viewer-column">
        <div id="viewer-container"></div>
    </div>

    <script src="hmt-image-library.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let currentViewer = null;
            const urnInput = document.getElementById('urn-input');
            const loadBtn = document.getElementById('load-urn-btn');
            const viewerContainerId = 'viewer-container';
            const rectListUl = document.querySelector('#rect-list ul');
            const noRectsMsg = document.getElementById('no-rects-msg');
            const clearAllBtn = document.getElementById('clear-all-rects-btn');

            function renderRectangleList(rectURNsString) {
                rectListUl.innerHTML = ''; // Clear previous list
                const urns = rectURNsString ? rectURNsString.split('\n').filter(urn => urn.trim() !== '') : [];

                if (urns.length === 0) {
                    noRectsMsg.style.display = 'block';
                    clearAllBtn.disabled = true;
                } else {
                    noRectsMsg.style.display = 'none';
                    clearAllBtn.disabled = false;
                    urns.forEach(urn => {
                        const li = document.createElement('li');
                        
                        const urnText = document.createElement('span');
                        urnText.textContent = urn;
                        li.appendChild(urnText);

                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = 'Remove';
                        removeBtn.className = 'remove-btn';
                        removeBtn.onclick = function() {
                            if (currentViewer) {
                                currentViewer.removeRectangle(urn);
                            }
                        };
                        li.appendChild(removeBtn);
                        rectListUl.appendChild(li);
                    });
                }
            }
            
            function loadViewer(urn) {
                if (currentViewer && typeof currentViewer.clearAllRectangles === 'function') { // Check if previous viewer exists and has the method
                    // Potentially clean up old viewer's global event listeners if they weren't instance-specific
                    // For now, HMTImageViewer re-binds its own listeners.
                }
                renderRectangleList(""); // Clear UI list for new image

                currentViewer = HMTImageLibrary.createViewer(
                    viewerContainerId,
                    urn,
                    {
                        onRectangleSelected: renderRectangleList
                        // onQuery: (queriedUrns) => { console.log("Queried URNs:", queriedUrns); } // Optional
                    }
                );
                 // Initialize list based on viewer's current state (should be empty)
                if (currentViewer) {
                    renderRectangleList(currentViewer.rectangles.map(r => r.urn).join('\n'));
                }
            }

            loadBtn.addEventListener('click', function() {
                const urn = urnInput.value.trim();
                if (urn) {
                    loadViewer(urn);
                } else {
                    alert("Please enter a valid URN.");
                }
            });

            clearAllBtn.addEventListener('click', function() {
                if (currentViewer && confirm("Are you sure you want to remove all rectangles?")) {
                    currentViewer.clearAllRectangles(); 
                }
            });

            // Load initial image
            loadViewer(urnInput.value);
        });
    </script>
</body>
</html>
```

**How to use `test-remove-rectangles.html`:**
1.  Save the updated `hmt-image-library.js` and this new HTML file (`test-remove-rectangles.html`) in the same directory.
2.  Open `test-remove-rectangles.html` in your browser.
3.  The default URN will load.
4.  Hold down the **Option (or Alt) key** and click and drag on the image to draw rectangles.
    *   The list of "Highlighted Rectangles" will update.
5.  Each rectangle in the list will have a "Remove" button. Clicking it will remove the rectangle from the image and the list.
6.  The "Clear All Rectangles" button will remove all drawn rectangles.
7.  You can enter a new URN and click "Load Image" to switch images. The rectangle list will reset.

This setup provides a good test environment for the rectangle management features. The interaction logic for selection (Option key behavior) has also been refined in the library for better usability.

### USER
Fantastic! Im going to publish this library on github! Could you write API documentation for it Markdown?

### ASSISTANT
Okay, this is an excellent idea! Good API documentation is crucial for any library.

Here is the API documentation in Markdown format for your `hmt-image-library.js`:

```markdown
# HMT Image Library API Documentation

## Overview

The HMT Image Library is a JavaScript library designed for interacting with images from the Homer Multitext (HMT) project via the IIIF (International Image Interoperability Framework) protocol. It allows developers to:

1.  Embed an interactive IIIF image viewer supporting panning and zooming.
2.  Enable users to select rectangular regions of interest (ROIs) on an image.
3.  Query which selected ROIs contain a specific point clicked by the user.
4.  Generate IIIF Image API URLs for HMT images, including specific regions and sizes.

The library constructs IIIF requests based on the HMT project's specific URN structure and IIIF server configuration.

## Installation / Usage

You can include this library in your HTML page directly from a CDN like jsDelivr once it's published to a public GitHub repository.

Replace `YOUR_GITHUB_USERNAME`, `YOUR_REPO_NAME`, and `VERSION_TAG_OR_COMMIT_HASH` with your actual GitHub details.

```html
<script src="https://cdn.jsdelivr.net/gh/YOUR_GITHUB_USERNAME/YOUR_REPO_NAME@VERSION_TAG_OR_COMMIT_HASH/hmt-image-library.js"></script>
```

Alternatively, you can download `hmt-image-library.js` and host it yourself:

```html
<script src="path/to/your/hmt-image-library.js"></script>
```

The library exposes a global object: `window.HMTImageLibrary`.

## Core Library Object: `HMTImageLibrary`

This is the main entry point for using the library.

### `HMTImageLibrary.createViewer(element, urn, options)`

Creates and initializes an interactive IIIF image viewer within a specified HTML element.

*   **Parameters:**
    *   `element` (String | HTMLElement): **Required**. The ID of the HTML div element that will contain the viewer, or the HTMLElement itself.
    *   `urn` (String): **Required**. The CITE2 URN identifying the HMT image (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`). The base URN (without `@` fragment) is used for image loading.
    *   `options` (Object): *Optional*. An object for configuring the viewer and its callbacks.
        *   `onRectangleSelected` (Function): *Optional*. A callback function invoked when a rectangle is drawn or removed.
            *   **Argument:** `rectURNsString` (String) - A newline-separated string of URNs for all currently selected rectangles. Each URN includes an ROI fragment (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.2,0.3,0.4`).
        *   `onQuery` (Function): *Optional*. A callback function invoked when the user Shift+clicks on the image.
            *   **Argument:** `matchingRectsURNs` (Array<String>) - An array of URNs (with ROI fragments) for all rectangles that contain the clicked point. An empty array is passed if no rectangles contain the point.

*   **Returns:** (HMTImageViewer | null)
    *   An instance of the `HMTImageViewer` class on success.
    *   `null` if an error occurs during initialization (an error will also be logged to the console).

*   **Example:**

    ```html
    <div id="myViewer" style="width: 600px; height: 400px; border: 1px solid black;"></div>
    <script>
        const viewerOptions = {
            onRectangleSelected: function(urns) {
                console.log("Rectangles selected/updated:\n" + urns);
                // Update your UI with this list
            },
            onQuery: function(matchingUrns) {
                if (matchingUrns.length > 0) {
                    alert("Clicked point is within:\n" + matchingUrns.join('\n'));
                } else {
                    alert("Clicked point is not within any rectangle.");
                }
            }
        };
        const viewerInstance = HMTImageLibrary.createViewer(
            'myViewer',
            'urn:cite2:hmt:vaimg.2017a:VA012RN_0013',
            viewerOptions
        );

        if (viewerInstance) {
            console.log("Viewer created successfully!");
        }
    </script>
    ```

### `HMTImageLibrary.getIIIFImageUrl(urnString, outputWidth, outputHeight)`

Generates a fully qualified IIIF Image API URL for a given HMT image URN. This function supports specifying a region of interest (ROI) via the URN fragment and can scale the image to a desired width or height while maintaining aspect ratio.

*   **Parameters:**
    *   `urnString` (String): **Required**. The CITE2 URN of the HMT image.
        *   It can be a base URN (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`).
        *   It can include an ROI fragment (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15`), where `x,y,w,h` are percentages from 0 to 1.
    *   `outputWidth` (Number): *Optional*. The desired output width of the image in pixels. If provided without `outputHeight`, the image will be scaled to this width, and height will be calculated to maintain aspect ratio.
    *   `outputHeight` (Number): *Optional*. The desired output height of the image in pixels. If provided without `outputWidth`, the image will be scaled to this height, and width will be calculated to maintain aspect ratio.
    *   If both `outputWidth` and `outputHeight` are provided, the image will be scaled to fit within these dimensions while maintaining aspect ratio (IIIF `!w,h` syntax).
    *   If neither is provided, the IIIF `size` parameter will be set to `full`.

*   **Returns:** (String)
    *   A string containing the complete IIIF Image API URL.
    *   The URL will request the image in `jpg` format.
    *   If an ROI is part of the `urnString`, the IIIF `region` parameter will be set to `pct:X,Y,W,H` (where X,Y,W,H are 0-100 values derived from the URN fragment).

*   **Throws:**
    *   `Error` if the `urnString` is invalid or cannot be parsed.

*   **Example:**

    ```javascript
    // Full image URL
    const fullImageUrl = HMTImageLibrary.getIIIFImageUrl('urn:cite2:hmt:vaimg.2017a:VA012RN_0013');
    console.log(fullImageUrl);
    // Expected: http://www.homermultitext.org/iipsrv?IIIF=/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a/VA012RN_0013.tif/full/full/0/default.jpg

    // Image scaled to 300px width
    const scaledWidthUrl = HMTImageLibrary.getIIIFImageUrl('urn:cite2:hmt:vaimg.2017a:VA012RN_0013', 300);
    console.log(scaledWidthUrl);
    // Expected: .../VA012RN_0013.tif/full/300,/0/default.jpg

    // Image with ROI, scaled to fit 200x150
    const roiScaledUrl = HMTImageLibrary.getIIIFImageUrl('urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.2,0.2', 200, 150);
    console.log(roiScaledUrl);
    // Expected: .../VA012RN_0013.tif/pct:10,10,20,20/!200,150/0/default.jpg
    ```

## `HMTImageViewer` Instance

An instance of `HMTImageViewer` is returned by `HMTImageLibrary.createViewer()`. It represents a single image viewer on the page and provides methods to interact with its state.

### Interaction Modes (User Input)

*   **Pan:** Click and drag the image.
*   **Zoom:** Use the mouse wheel.
*   **Select Rectangle:** Hold down `Option` (Mac) or `Alt` (Windows/Linux) key, then click and drag.
*   **Query Rectangles:** Hold down `Shift` key and click on the image.

### Methods

#### `viewerInstance.removeRectangle(rectangleURNToRemove)`

Removes a specific highlighted rectangle from the viewer's list of selected rectangles.

*   **Parameters:**
    *   `rectangleURNToRemove` (String): **Required**. The full URN of the rectangle to remove, including its `@x,y,w,h` fragment (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.2,0.3,0.4`). This URN should exactly match one of the URNs previously reported by the `onRectangleSelected` callback.

*   **Returns:** (Boolean)
    *   `true` if the specified rectangle was found and removed.
    *   `false` if no rectangle matching the URN was found.

*   **Side Effects:**
    *   The viewer display is updated to remove the visual highlight of the rectangle.
    *   The `onRectangleSelected` callback (if configured during viewer creation) is invoked with the updated list of rectangle URNs.

*   **Example:**

    ```javascript
    // Assuming 'viewerInstance' is an existing HMTImageViewer
    // and 'urnToRemove' is a URN obtained from the onRectangleSelected callback
    const urnToRemove = 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15';
    if (viewerInstance.removeRectangle(urnToRemove)) {
        console.log(`Rectangle ${urnToRemove} removed.`);
    } else {
        console.log(`Rectangle ${urnToRemove} not found.`);
    }
    ```

#### `viewerInstance.clearAllRectangles()`

Removes all currently highlighted rectangles from the viewer.

*   **Parameters:** None.
*   **Returns:** Void.

*   **Side Effects:**
    *   The viewer display is updated to remove all visual highlights of rectangles.
    *   The `onRectangleSelected` callback (if configured) is invoked with an empty string (or no argument if no rectangles were present).

*   **Example:**

    ```javascript
    // Assuming 'viewerInstance' is an existing HMTImageViewer
    if (confirm("Are you sure you want to clear all selected regions?")) {
        viewerInstance.clearAllRectangles();
        console.log("All rectangles cleared.");
    }
    ```

## URN Structure for HMT IIIF

The library internally handles the construction of IIIF paths based on the HMT CITE2 URN structure:

*   **CITE2 URN Example:** `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`
    1.  `urn`
    2.  `cite2`
    3.  `hmt` (Namespace)
    4.  `vaimg.2017a` (Collection Component: `part1.part2`)
    5.  `VA012RN_0013` (Object Identifier)

*   **IIIF Base Path:** `/project/homer/pyramidal/deepzoom`
*   **Resulting IIIF Prefix:** `/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a`
*   **Image Identifier for IIIF:** `VA012RN_0013.tif`

ROI fragments are appended to the base URN with an `@` symbol, followed by four comma-separated decimal values representing x, y, width, and height as percentages (0.0 to 1.0) of the total image dimensions. Example: `@0.25,0.50,0.40,0.15`.
```

This Markdown documentation should provide a solid foundation for users of your library. You can save this as `API.md` or `README.md` in your GitHub repository. Remember to update the jsDelivr link placeholders once you have the repository set up.