### USER
I want to build a javascript library, packaged so that I can add it to a GitHub repo and use it via jsDeliver. The package should have a function that accepts a CITE2 URN as a parameter identifying an image from the Homer Multitext project (HMT) available through the IIIF protocol, and then lets the user zoom and pan the image.  The design should support including multiple instances of a viewer on a single web page, with each viewer supporting panning and zooming of the image it was constructed with. The IIIF viewer should be built from scratch rather than using a library like OpenSeaDragon.  Use anonymous CORS to avoid restrictions on cross-origin access.
Here's the information you need to define an IIIF request for the Homer Muiltitext project.
Protocol: http
Server: www.homermultitext.org/iipsrv?IIIF=
Prefix: The information we need to construct the correct prefix is included in the image identifier. Images are identified with CITE2 URN, which have 5 components separated by colons. The IIIF prefix for the HMT server is constructed from a base path `/project/homer/pyramidal/deepzoom`, to which we append three further elements, joining each with a slash `/`. The first piece we append is the URN's namespace, the third colon-delimited component of the URN; the second and third pieces we append are taken from the collection component, which is the fourth colon-delimited part of the URN. This component has two parts separated by a period: we append each of these separately.
Image: images in the HMT service are in TIF format. To form the correct image identify, append `.tif` to the object identifier (final component of the CITE2 URN.)
Here's a complete example: for the CITE2 URN `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`, the namespace is `hmt` (third component); the workspace component is `vaimg.2017a` (fourth component); the object identifier is `VA012RN_0013`.  We form the IIIF prefix by joinging to the base path `/project/homer/pyramidal/deepzoom` the namespace value, and two period-separted parts of the collection value. The full  IIIF prefix is therefore  `/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a`. We form the image identifier by appending `.tif` to the objectcompnonent and get `VA012RN_0013.tif`. A complete `info` request for this image on the HMT IIIF service would therefore be `http://www.homermultitext.org/iipsrv?IIIF=/project/homer/pyramidal/deepzoom/hmt/vaimg/2017a/VA012RN_0013.tif/info.json`
To test the library, please also write an HTML file that includes the library of functions from a local file, and tests the image browsing  function with a page viewing two images with the URNs `urn:cite2:hmt:vaimg.2017a:VA012RN_0013` and `urn:cite2:hmt:vaimg.2017a:VA013RN_0014`.

### ASSISTANT
Okay, this is an exciting project! We'll build a JavaScript library for a basic IIIF image viewer with zoom and pan capabilities, specifically tailored for Homer Multitext URNs.

Here's the plan:

1.  **JavaScript Library (`hmt-iiif-viewer.js`):**
    *   An IIFE (Immediately Invoked Function Expression) to create a global `HMTIIIFViewer` object.
    *   `parseCite2Urn(urnString)`: A helper function to break down the CITE2 URN into its components.
    *   `buildIIIFBaseUrl(parsedUrn)`: A helper to construct the IIIF prefix and image identifier base (e.g., `/path/to/image.tif`).
    *   `HMTIIIFViewer.createViewer(elementId, cite2Urn)`: The main function.
        *   Takes the ID of a DOM element (e.g., a `div`) and the CITE2 URN.
        *   Fetches `info.json` for the image to get its dimensions.
        *   Creates an `<img>` tag within the provided element.
        *   Manages state: `currentScale` (screen pixels per original image pixel), `centerXOrig`, `centerYOrig` (center of view in original image coordinates).
        *   `renderImage()`: Calculates the IIIF region and size parameters based on the current state and viewport dimensions, then updates the `<img>` tag's `src`.
        *   Attaches event listeners for:
            *   Mouse wheel (`wheel`) for zooming.
            *   Mouse down, move, up, leave (`mousedown`, `mousemove`, `mouseup`, `mouseleave`) for panning.
        *   Includes logic to constrain panning and zooming.
    *   Uses anonymous CORS for `fetch` requests (which is the default `mode: 'cors'` behavior for cross-origin requests).

2.  **HTML Test Page (`test.html`):**
    *   Includes basic CSS for two viewer containers.
    *   Includes the `hmt-iiif-viewer.js` library.
    *   Contains two `div` elements that will host the viewers.
    *   A script block to initialize two instances of the viewer with the specified URNs.

Let's start with the JavaScript library.

**`hmt-iiif-viewer.js`**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    function parseCite2Urn(urnString) {
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) { // allow for no period, though example has it
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : ''; // Handle cases with or without version part like '.2017a'
        
        const objectId = parts[4];

        return {
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId
        };
    }

    function buildIIIFImageDataBase(parsedUrn) {
        if (!parsedUrn) return null;
        // Example: /project/homer/pyramidal/deepzoom/hmt/vaimg/2017a/VA012RN_0013.tif
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) { // Only append version if it exists
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    function createViewer(elementId, cite2Urn) {
        const container = document.getElementById(elementId);
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        container.innerHTML = ''; // Clear previous content
        container.style.overflow = 'hidden';
        container.style.position = 'relative'; // For absolute positioning of image
        container.style.cursor = 'grab';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute'; // Will be positioned by renderImage
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false; // Prevent browser's default image drag
        imgElement.alt = `IIIF image for ${cite2Urn}`;
        container.appendChild(imgElement);
        
        // Spinner
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...'; // Basic spinner
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none'; // Hidden by default
        container.appendChild(spinner);

        let imageInfo = null; // { width, height }
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;

        // Pan/zoom state
        let currentScale = 1.0; // screen pixels per original image pixel
        let centerXOrig = 0;    // center of view in original image coordinates
        let centerYOrig = 0;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Debounce rendering to avoid too many requests during rapid interaction
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150; // ms

        const parsedUrn = parseCite2Urn(cite2Urn);
        if (!parsedUrn) {
            container.innerHTML = `<p style="color:red;">Invalid CITE2 URN: ${cite2Urn}</p>`;
            return;
        }
        const iiifImageDataPath = buildIIIFImageDataBase(parsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${cite2Urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;
        
        imgElement.addEventListener('load', () => spinner.style.display = 'none');
        imgElement.addEventListener('error', () => {
            spinner.style.display = 'none';
            container.innerHTML = `<p style="color:red;">Error loading image tile.</p>`;
        });


        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                // Initial view: fit image into viewport
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );
                constrainState(); // Apply initial constraints
                renderImage();    // Initial render
                setupEventListeners();
            })
            .catch(error => {
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() {
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }

        function renderImage() {
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            // Calculate the region of the original image to fetch
            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;

            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            // Clamp region to image boundaries
            // Requested X,Y must be within [0, image.width - 1] and [0, image.height - 1]
            // Requested W,H must be > 0
            
            // Adjust X, Y if they are out of bounds, then adjust W, H if needed.
            if (reqXOrig < 0) {
                // reqWidthOrig += reqXOrig; // Effectively reduces width if part is off-screen
                reqXOrig = 0;
            }
            if (reqYOrig < 0) {
                // reqHeightOrig += reqYOrig;
                reqYOrig = 0;
            }

            // Ensure requested width/height don't exceed image dimensions from the (potentially new) X,Y
            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            // Ensure width and height are at least 1 pixel
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            // Final check to prevent requesting beyond image boundaries if rounding caused issues
            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0; // If width itself is larger than image width
            if (reqYOrig < 0) reqYOrig = 0;


            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            // Request size that fits the viewport. Server will maintain aspect ratio.
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            // The image returned by IIIF with !w,h will fit *within* w,h.
            // Style the img tag to fill the container.
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';
        }

        function constrainState() {
            if (!imageInfo) return;

            // Min scale: image is 1/4th the size of "fit to screen"
            // Max scale: 4 screen pixels per original image pixel (or image full res, whichever is larger for max)
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale);
            currentScale = Math.min(4, currentScale); // Max zoom factor of 4

            // Pan constraints
            // Effective width/height of the full image if displayed at currentScale
            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            // If image is smaller than viewport, center it
            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                // Min/max center X in original image coordinates
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        function setupEventListeners() {
            // Zoom
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left; // mouse X relative to viewport
                const mouseYvp = event.clientY - rect.top;  // mouse Y relative to viewport

                // Point on original image under mouse before zoom
                const ptXOrig = centerXOrig + (mouseXvp - viewportWidth / 2) / currentScale;
                const ptYOrig = centerYOrig + (mouseYvp - viewportHeight / 2) / currentScale;

                const newScale = currentScale * zoomFactor;
                
                // Update currentScale first before using it in new center calculation
                currentScale = newScale;
                constrainState(); // Apply scale constraints before calculating new center

                // Recalculate center so the point under mouse stays fixed
                centerXOrig = ptXOrig - (mouseXvp - viewportWidth / 2) / currentScale;
                centerYOrig = ptYOrig - (mouseYvp - viewportHeight / 2) / currentScale;
                
                constrainState(); // Apply all constraints
                scheduleRender();
            });

            // Pan
            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return; // Only left click
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                container.style.cursor = 'grabbing';
                event.preventDefault();
            });

            container.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                centerXOrig -= dx / currentScale;
                centerYOrig -= dy / currentScale;
                
                constrainState();
                scheduleRender();
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                    // Final render already scheduled by mousemove, or if no move, not needed.
                    // scheduleRender(); // Could ensure one final high-quality render if needed.
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                    // scheduleRender(); 
                }
            });
            
            // Handle viewport resize (basic)
            // A more robust solution would use ResizeObserver
            window.addEventListener('resize', function() {
                viewportWidth = container.clientWidth;
                viewportHeight = container.clientHeight;
                constrainState();
                scheduleRender();
            });
        }
    }

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**`test.html`**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMT IIIF Viewer Test</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .viewer-container {
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
            background-color: #fff;
            margin-bottom: 20px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }
        h2 {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <h1>Homer Multitext IIIF Viewer Test</h1>

    <div>
        <h2>Image 1: urn:cite2:hmt:vaimg.2017a:VA012RN_0013</h2>
        <div id="viewer1" class="viewer-container"></div>
    </div>

    <div>
        <h2>Image 2: urn:cite2:hmt:vaimg.2017a:VA013RN_0014</h2>
        <div id="viewer2" class="viewer-container"></div>
    </div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urn1 = 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013';
            const urn2 = 'urn:cite2:hmt:vaimg.2017a:VA013RN_0014';

            HMTIIIFViewer.createViewer('viewer1', urn1);
            HMTIIIFViewer.createViewer('viewer2', urn2);
        });
    </script>

</body>
</html>
```

**To Use This:**

1.  Save the JavaScript code as `hmt-iiif-viewer.js`.
2.  Save the HTML code as `test.html` in the same directory.
3.  Open `test.html` in your web browser.

**Explanation and Features:**

*   **URN Parsing:** The `parseCite2Urn` function correctly breaks down the URNs according to the HMT structure.
*   **IIIF URL Construction:** `buildIIIFImageDataBase` and the logic within `createViewer` construct the `info.json` and image tile URLs.
*   **Multiple Instances:** `createViewer` is designed to be called multiple times, each instance managing its own state and DOM elements.
*   **Zoom:** Implemented using the mouse wheel. It zooms towards/away from the mouse cursor's position.
*   **Pan:** Implemented by clicking and dragging the image.
*   **Constraints:** Basic constraints are in place to prevent zooming out/in too far and panning the image completely out of view.
*   **IIIF Image Requests:** On each pan/zoom, the viewer calculates the appropriate region of the full-resolution image to display and requests it from the IIIF server, scaled to fit the viewport (`!viewportWidth,viewportHeight`). This leverages the IIIF server's capability to deliver appropriately sized image data.
*   **CORS:** `fetch` handles anonymous CORS by default. The HMT server supports this.
*   **Error Handling:** Basic error messages are displayed in the viewer if `info.json` fails to load or the URN is invalid. Image load errors are also handled.
*   **Loading Indicator:** A simple "Loading..." text appears while images/info are being fetched.
*   **Debouncing:** Image rendering is debounced to prevent excessive requests during rapid mouse movements or wheel scrolling, improving performance and reducing server load.
*   **Responsive (Basic):** The viewer attempts to re-render correctly if the window is resized, recalculating viewport dimensions.

**For jsDelivr:**

1.  Create a GitHub repository.
2.  Add `hmt-iiif-viewer.js` to this repository.
3.  Push your changes and tag a release (e.g., `v1.0.0`).
4.  You can then access your library via jsDelivr using a URL like:
    `https://cdn.jsdelivr.net/gh/YOUR_USERNAME/YOUR_REPONAME@v1.0.0/hmt-iiif-viewer.js`
    Or for the latest commit on a branch (e.g., `main`):
    `https://cdn.jsdelivr.net/gh/YOUR_USERNAME/YOUR_REPONAME@main/hmt-iiif-viewer.js`

This solution provides a good foundation for a custom IIIF viewer as requested.

### USER
Great! Let’s create a test file that allows a user to enter a URN and displays the image.  Populate the input with a default value of urn:cite2:hmt:vaimg.2017a:VA012RN_0013 so that the user

### ASSISTANT
Okay, let's create an interactive test page where a user can input a URN and view the image. We'll pre-populate the input and also load that default image when the page first opens.

Here's the `interactive-test.html` file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive HMT IIIF Viewer Test</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .controls label {
            font-weight: bold;
        }
        .controls input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 300px; /* Give it some decent width */
        }
        .controls button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .viewer-container {
            width: 80vw; /* Responsive width */
            max-width: 800px; /* Max width */
            height: 60vh; /* Responsive height */
            max-height: 600px; /* Max height */
            border: 1px solid #ccc;
            background-color: #e9e9e9; /* Slightly different background for viewer */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }
        #viewer-status {
            margin-top: 10px;
            font-style: italic;
            color: #555;
        }
    </style>
</head>
<body>
    <h1>Interactive Homer Multitext IIIF Viewer</h1>

    <div class="controls">
        <label for="urnInput">CITE2 URN:</label>
        <input type="text" id="urnInput" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013">
        <button id="loadButton">Load Image</button>
    </div>

    <div id="imageViewer" class="viewer-container">
        <!-- The IIIF viewer will be rendered here -->
    </div>
    <div id="viewer-status">Enter a HMT CITE2 URN and click "Load Image".</div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInputElement = document.getElementById('urnInput');
            const loadButtonElement = document.getElementById('loadButton');
            const viewerContainerId = 'imageViewer';
            const statusElement = document.getElementById('viewer-status');

            function loadImageViewer() {
                const urn = urnInputElement.value.trim();
                if (urn) {
                    statusElement.textContent = `Loading URN: ${urn}...`;
                    // The createViewer function clears the container, so it's safe to call repeatedly
                    HMTIIIFViewer.createViewer(viewerContainerId, urn);
                    // The viewer itself will show "Loading..." or error messages
                    // We can clear our status once createViewer is called, or let the viewer handle it.
                    // For now, we'll assume createViewer handles visual feedback.
                } else {
                    statusElement.textContent = 'Please enter a valid URN.';
                    document.getElementById(viewerContainerId).innerHTML = '<p style="color:orange;">Please enter a URN.</p>';
                }
            }

            loadButtonElement.addEventListener('click', loadImageViewer);

            // Also allow Enter key in the input field to trigger loading
            urnInputElement.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent form submission if it were in a form
                    loadImageViewer();
                }
            });

            // Load the default URN when the page loads
            statusElement.textContent = `Loading default URN: ${urnInputElement.value}...`;
            loadImageViewer();
        });
    </script>

</body>
</html>
```

**To use this:**

1.  Make sure you have `hmt-iiif-viewer.js` in the same directory as this new `interactive-test.html` file.
2.  Open `interactive-test.html` in your web browser.

**Features of this test page:**

1.  **Input Field:** A text input is provided where users can type or paste a CITE2 URN.
2.  **Default Value:** The input field is pre-filled with `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`.
3.  **Load Button:** A "Load Image" button triggers the image loading process.
4.  **Viewer Container:** A `div` with the ID `imageViewer` is designated to host the IIIF image.
5.  **Automatic Load:** The image corresponding to the default URN is automatically loaded when the page opens.
6.  **Enter Key Support:** Pressing "Enter" in the input field also triggers loading the image.
7.  **Status Message:** A small text area below the viewer provides feedback to the user (e.g., "Loading URN...").
8.  **Basic Styling:** Some CSS is included to make the page look a bit more organized.

This interactive test file should give you a good way to quickly test different URNs with your `hmt-iiif-viewer.js` library.

### USER
Great! Now let’s consider a further feature of URN notation. Image URNs can have an optional extension with @ followed by 4 comma-separated numbers defining a rectangular area on the image in percentage terms scaled from 0 to 1. Example: cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15 defines a rectangle starting at an x,y point 25% along the X axis and 50% along the Y axis, and extending 40% in X and 15% in Y.  Ignore this extension in forming the IIIF request, but when drawing the image, highlight the rectangular area. The same area of the image should remain highlighted as the user pans and zooms.

### ASSISTANT
Okay, this is a neat extension! We'll modify the library to parse this optional ROI suffix, ignore it for IIIF requests, but use it to draw a persistent highlight on the image.

Here's how we'll update `hmt-iiif-viewer.js`:

1.  **Update `parseCite2Urn`**:
    *   It will now check the object identifier part of the URN for an `@` symbol.
    *   If found, it will parse the `x,y,w,h` percentage values.
    *   The `objectId` will be the part *before* the `@`.
    *   The parsed ROI (if valid) will be stored in the returned object.

2.  **Update `createViewer`**:
    *   A `div` element for the highlight rectangle will be created and styled (e.g., red border, transparent background, `pointer-events: none`).
    *   If an ROI is parsed from the URN, its percentage coordinates will be converted to absolute pixel coordinates based on the full image dimensions (obtained from `info.json`).

3.  **Update `renderImage` (or a new helper function)**:
    *   On every render (pan/zoom), the position and size of the highlight `div` will be recalculated.
    *   The calculation will transform the ROI's absolute pixel coordinates (on the original full image) to screen coordinates relative to the current viewport, considering `currentScale` and `centerXOrig`, `centerYOrig`.
    *   The `container`'s `overflow: hidden` will naturally clip the highlight if it's partially outside the view.

Here's the modified `hmt-iiif-viewer.js`:

**`hmt-iiif-viewer.js` (with ROI highlighting)**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    function parseCite2Urn(urnString) {
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val)); // Ensure parsing as float
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h }; // Store as 0-1 percentages
                } else {
                    console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId, // This is now stripped of the @roi part
            roi: roi
        };
    }

    function buildIIIFImageDataBase(parsedUrn) {
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`; // Uses the objectId without ROI
        return path;
    }

    function createViewer(elementId, cite2Urn) {
        const container = document.getElementById(elementId);
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        container.style.cursor = 'grab';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${cite2Urn}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let highlightElement = null; // For ROI
        let roiOrigPx = null; // ROI in original image pixel coordinates {x, y, w, h}

        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;

        let currentScale = 1.0;
        let centerXOrig = 0;
        let centerYOrig = 0;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;

        const parsedUrn = parseCite2Urn(cite2Urn);
        if (!parsedUrn) {
            container.innerHTML = `<p style="color:red;">Invalid CITE2 URN: ${cite2Urn}</p>`;
            return;
        }
        const iiifImageDataPath = buildIIIFImageDataBase(parsedUrn); // Uses objectId without ROI
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${cite2Urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;
        
        imgElement.addEventListener('load', () => spinner.style.display = 'none');
        imgElement.addEventListener('error', () => {
            spinner.style.display = 'none';
            container.innerHTML = `<p style="color:red;">Error loading image tile.</p>`;
        });

        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                // Initialize ROI highlight if URN has ROI
                if (parsedUrn.roi && imageInfo) {
                    highlightElement = document.createElement('div');
                    highlightElement.style.position = 'absolute';
                    highlightElement.style.border = '3px solid rgba(255, 0, 0, 0.7)';
                    highlightElement.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                    highlightElement.style.boxSizing = 'border-box';
                    highlightElement.style.pointerEvents = 'none'; // IMPORTANT
                    highlightElement.style.display = 'none'; // Hidden until first render
                    container.appendChild(highlightElement); // Add to container, above image

                    roiOrigPx = {
                        x: parsedUrn.roi.x * imageInfo.width,
                        y: parsedUrn.roi.y * imageInfo.height,
                        w: parsedUrn.roi.w * imageInfo.width,
                        h: parsedUrn.roi.h * imageInfo.height
                    };
                }

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => {
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() {
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }

        function updateHighlightOverlay() {
            if (!highlightElement || !roiOrigPx || !imageInfo || viewportWidth === 0 || viewportHeight === 0) {
                if (highlightElement) highlightElement.style.display = 'none';
                return;
            }

            // Top-left of the viewport in original image coordinates
            const viewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
            const viewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;

            // Position of ROI's top-left relative to viewport's top-left, in screen pixels
            const highlightScreenX = (roiOrigPx.x - viewOrigTopLeftX) * currentScale;
            const highlightScreenY = (roiOrigPx.y - viewOrigTopLeftY) * currentScale;

            // Size of ROI in screen pixels
            const highlightScreenWidth = roiOrigPx.w * currentScale;
            const highlightScreenHeight = roiOrigPx.h * currentScale;

            if (highlightScreenWidth < 1 || highlightScreenHeight < 1) { // Too small to see
                highlightElement.style.display = 'none';
                return;
            }

            highlightElement.style.left = `${Math.round(highlightScreenX)}px`;
            highlightElement.style.top = `${Math.round(highlightScreenY)}px`;
            highlightElement.style.width = `${Math.round(highlightScreenWidth)}px`;
            highlightElement.style.height = `${Math.round(highlightScreenHeight)}px`;
            highlightElement.style.display = 'block';
        }


        function renderImage() {
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqXOrig + reqWidthOrig > imageInfo.width) reqWidthOrig = imageInfo.width - reqXOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqHeightOrig = imageInfo.height - reqYOrig;
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlay(); // Update the highlight after image parameters are set
        }

        function constrainState() {
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale);
            currentScale = Math.min(4, currentScale);

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        function setupEventListeners() {
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                const ptXOrig = centerXOrig + (mouseXvp - viewportWidth / 2) / currentScale;
                const ptYOrig = centerYOrig + (mouseYvp - viewportHeight / 2) / currentScale;
                
                currentScale *= zoomFactor; // Apply zoom first
                constrainState(); // Constrain scale first

                centerXOrig = ptXOrig - (mouseXvp - viewportWidth / 2) / currentScale;
                centerYOrig = ptYOrig - (mouseYvp - viewportHeight / 2) / currentScale;
                
                constrainState(); // Constrain pan
                scheduleRender();
            });

            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return;
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                container.style.cursor = 'grabbing';
                event.preventDefault();
            });

            container.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                centerXOrig -= dx / currentScale;
                centerYOrig -= dy / currentScale;
                
                constrainState();
                scheduleRender();
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });
            
            window.addEventListener('resize', function() {
                viewportWidth = container.clientWidth;
                viewportHeight = container.clientHeight;
                constrainState();
                scheduleRender(); // Re-render on resize
            });
        }
    }

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Key changes:**

*   **`parseCite2Urn`**:
    *   Splits the last component of the URN by `@`.
    *   Parses the 4 comma-separated values as floats between 0 and 1.
    *   Stores them in `parsedUrn.roi = {x, y, w, h}` or `null` if invalid/not present.
    *   `parsedUrn.objectId` now correctly refers to the ID part before any `@roi`.
*   **`createViewer`**:
    *   Initializes `highlightElement = null` and `roiOrigPx = null`.
    *   After `info.json` is fetched and `imageInfo` is available:
        *   If `parsedUrn.roi` exists, it creates the `highlightElement` `div`.
        *   `pointer-events: none;` is crucial so the highlight doesn't interfere with mouse events on the image.
        *   `roiOrigPx` is calculated by converting percentage ROI to absolute pixel values on the original image.
*   **`updateHighlightOverlay()` function**:
    *   This new function is responsible for calculating the screen position and size of the highlight.
    *   It takes `centerXOrig`, `centerYOrig`, `currentScale`, `viewportWidth`, `viewportHeight`, and `roiOrigPx` to determine the `left`, `top`, `width`, and `height` style properties for `highlightElement`.
    *   It's called at the end of `renderImage()` and also initially after `imageInfo` is loaded to draw the first highlight.
    *   It hides the highlight if it becomes too small to be practically visible.
*   **`renderImage()`**: Calls `updateHighlightOverlay()` after setting the image source and style.
*   **Styling**: The highlight has a semi-transparent red border and a very light semi-transparent red background for better visibility.

**To test this with the `interactive-test.html`:**

You can now enter a URN with an ROI suffix in the input field, for example:
`urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.25,0.5,0.5`
This should load the image and draw a red rectangle covering the central 50% x 50% area of the image. The highlight should stay correctly positioned as you pan and zoom.

Another example using the URN provided in the prompt:
`urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15`

This enhancement makes the viewer more versatile for focusing on specific regions of interest defined directly in the URN.

### USER
The initial highlighting is perfect, but the coordinates are not adjusted correctly when the image is zoomed or panned.  The coordinates should be adjusted to reflect the current zoom and pan values.  Please update the code to ensure that the rectangle is always drawn in the same position relative to the image, regardless of the current zoom and pan values.

### ASSISTANT
You're absolutely correct. My apologies! The previous logic for `updateHighlightOverlay` did not correctly account for the actual rendered size and position of the image content within the viewport, especially when aspect ratios differ (leading to `object-fit: contain` letterboxing/pillarboxing).

Let's implement the more robust calculation we worked through in the thought process. This involves:

1.  Determining the actual dimensions (`finalReqW`, `finalReqH`) of the region from the original image that is being requested from the IIIF server (after clamping and rounding).
2.  Calculating the `serverScale`: the true scale factor mapping these original image region pixels to screen pixels for the image content delivered by IIIF and displayed within the `<img>` tag.
3.  Calculating the dimensions of this displayed image content (`renderedImageContentWidth`, `renderedImageContentHeight`) on the screen.
4.  Calculating the offsets (`contentOffsetX`, `contentOffsetY`) of this displayed image content within the main `container` (due to `object-fit: contain`).
5.  Positioning and scaling the ROI highlight relative to this accurately placed and scaled image content.

Here's the updated `hmt-iiif-viewer.js` with the corrected `updateHighlightOverlay` logic:

**`hmt-iiif-viewer.js` (Corrected ROI Highlighting)**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    function parseCite2Urn(urnString) {
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }

    function buildIIIFImageDataBase(parsedUrn) {
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    function createViewer(elementId, cite2Urn) {
        const container = document.getElementById(elementId);
        // ... (rest of initial setup: container, imgElement, spinner as before)
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        container.style.cursor = 'grab';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0'; // These might be adjusted if using object-fit letterboxing
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${cite2Urn}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let highlightElement = null;
        let roiOrigPx = null; // ROI in original image pixel coordinates {x, y, w, h}

        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;

        let currentScale = 1.0;
        let centerXOrig = 0;
        let centerYOrig = 0;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;

        // Store the region requested from IIIF for highlight calculation
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };


        const parsedUrn = parseCite2Urn(cite2Urn);
        if (!parsedUrn) {
            container.innerHTML = `<p style="color:red;">Invalid CITE2 URN: ${cite2Urn}</p>`;
            return;
        }
        const iiifImageDataPath = buildIIIFImageDataBase(parsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${cite2Urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;
        
        imgElement.addEventListener('load', () => {
            spinner.style.display = 'none';
            // Update highlight overlay after image has loaded and its dimensions are effectively known
            // (though IIIF size parameter !w,h should give us the info)
            updateHighlightOverlay();
        });
        imgElement.addEventListener('error', () => {
            spinner.style.display = 'none';
            container.innerHTML = `<p style="color:red;">Error loading image tile.</p>`;
        });

        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                if (parsedUrn.roi && imageInfo) {
                    highlightElement = document.createElement('div');
                    highlightElement.style.position = 'absolute';
                    highlightElement.style.border = '3px solid rgba(255, 0, 0, 0.7)';
                    highlightElement.style.backgroundColor = 'rgba(255, 0, 0, 0.05)'; // Lighter fill
                    highlightElement.style.boxSizing = 'border-box';
                    highlightElement.style.pointerEvents = 'none';
                    highlightElement.style.display = 'none';
                    container.appendChild(highlightElement);

                    roiOrigPx = {
                        x: parsedUrn.roi.x * imageInfo.width,
                        y: parsedUrn.roi.y * imageInfo.height,
                        w: parsedUrn.roi.w * imageInfo.width,
                        h: parsedUrn.roi.h * imageInfo.height
                    };
                }

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => {
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() {
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }

        function updateHighlightOverlay() {
            if (!highlightElement || !roiOrigPx || !imageInfo || viewportWidth === 0 || viewportHeight === 0 ||
                lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) {
                if (highlightElement) highlightElement.style.display = 'none';
                return;
            }

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;

            // Calculate the scale factor the IIIF server uses for the !w,h request.
            // This is the scale from the requested region (finalReqW, finalReqH)
            // to the dimensions of the image content returned by the server.
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);

            // Dimensions of the actual image content rendered by the <img> tag
            // (respecting aspect ratio, potentially letterboxed/pillarboxed)
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;

            // Offsets of this rendered content within the imgElement/container
            // due to object-fit: contain (or equivalent IIIF scaling)
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            // ROI's top-left relative to the top-left of the requested IIIF region (finalReqX, finalReqY)
            // These are in original image pixel coordinates.
            const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
            const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;

            // Position of ROI's top-left *within* the actual rendered image content on screen
            const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
            const roiInContentY_screen = roiRelToRegionY_orig * serverScale;

            // Size of ROI on screen
            const roiContentWidth_screen = roiOrigPx.w * serverScale;
            const roiContentHeight_screen = roiOrigPx.h * serverScale;

            // Final position and size for the highlight div, relative to the container
            const highlightDivX = contentOffsetX + roiInContentX_screen;
            const highlightDivY = contentOffsetY + roiInContentY_screen;
            // No change to width/height calculation, it's purely scaled by serverScale
            const highlightDivW = roiContentWidth_screen;
            const highlightDivH = roiContentHeight_screen;
            
            // Hide if too small or completely off-screen (basic check)
            if (highlightDivW < 1 || highlightDivH < 1 ||
                highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                highlightElement.style.display = 'none';
            } else {
                highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                highlightElement.style.display = 'block';
            }
        }


        function renderImage() {
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            // Clamp region to image boundaries
            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            // Final check (redundant if above logic is perfect, but safe)
            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
             // Ensure width/height are not negative after clamping X/Y
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;


            // Store the finally calculated region for the highlight overlay
            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`; // Fit within, maintain aspect
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            // The imgElement itself fills the container. object-fit handles the actual image.
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain'; // Crucial for aspect ratio

            // Call updateHighlightOverlay here, as lastRequestedRegion is now set.
            // It's also called on imgElement.load for initial draw after image is present.
            // Calling it here ensures it updates immediately on pan/zoom logic, before image loads.
            updateHighlightOverlay();
        }

        // constrainState function remains the same
        function constrainState() {
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); // Min zoom: 1/4 of fit-to-screen
            currentScale = Math.min(4, currentScale); // Max zoom factor of 4 (screen px per orig px)

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        // setupEventListeners function remains largely the same
        function setupEventListeners() {
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                // Calculate the point in the original image under the mouse
                // This requires knowing the actual rendered image's offset and scale
                // For simplicity in zoom, we'll use currentScale to approximate.
                // A more precise way would use serverScale and contentOffset from updateHighlightOverlay.
                // However, currentScale should be close enough for good UX for zoom point.
                
                // Top-left of the viewport in original image coordinates (idealized)
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                
                // Convert mouse viewport (screen) coords to original image coords
                // This step needs to account for letterboxing if we want perfect mouse point zooming.
                // For now, let's assume mouseXvp/mouseYvp are over actual image content,
                // or that currentScale is a good enough proxy for serverScale for this interaction.
                // This is a known simplification spot if zoom point feels off with letterboxing.

                // Point on original image under mouse IF image filled viewport at currentScale
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                const oldScale = currentScale;
                currentScale *= zoomFactor;
                constrainState(); // Constrain new scale

                // Adjust centerXOrig, centerYOrig to keep ptXOrig, ptYOrig at the same mouse position
                // Recalculate new ideal top-left based on new currentScale
                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);

                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); // Apply pan constraints
                scheduleRender();
            });

            // Pan event listeners (mousedown, mousemove, mouseup, mouseleave) remain the same
            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return; // Only left click
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                container.style.cursor = 'grabbing';
                event.preventDefault();
            });

            container.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                // Pan amount in original image pixels
                centerXOrig -= dx / currentScale; // Use currentScale here for panning speed
                centerYOrig -= dy / currentScale;
                
                constrainState();
                scheduleRender();
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });
            
            // Resize listener
            window.addEventListener('resize', function() {
                // Debounce resize handling
                clearTimeout(renderTimeout); // Clear any pending image render
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage(); // Re-render on resize
                }, DEBOUNCE_DELAY + 50); // Slightly longer delay for resize
            });
        }
    } // End of createViewer

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Key Changes in this Correction:**

1.  **`lastRequestedRegion` Variable:** A new variable `lastRequestedRegion` is introduced in `createViewer`'s scope. It will store the `x, y, w, h` of the image region that was *actually requested* from the IIIF server (after all clamping and rounding).
2.  **Populating `lastRequestedRegion`:** In `renderImage()`, right before constructing the IIIF URL, the calculated and clamped `reqXOrig, reqYOrig, reqWidthOrig, reqHeightOrig` are stored into `lastRequestedRegion`.
3.  **`updateHighlightOverlay()` Reworked:**
    *   It now uses `lastRequestedRegion.x, .y, .w, .h` as `finalReqX, finalReqY, finalReqW, finalReqH`.
    *   **`serverScale`**: Correctly calculated as `Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH)`. This is the crucial scale factor that the IIIF server applies to the `finalReqW`x`finalReqH` region to make it fit into `!viewportWidth,viewportHeight`.
    *   **`renderedImageContentWidth/Height`**: Calculated using `finalReqW * serverScale` and `finalReqH * serverScale`. These are the actual pixel dimensions of the image content visible on screen.
    *   **`contentOffsetX/Y`**: Calculated as `(viewportWidth - renderedImageContentWidth) / 2` and `(viewportHeight - renderedImageContentHeight) / 2`. These are the offsets of the actual image content from the top-left of the `container` due to `object-fit: contain`.
    *   The ROI's position and size are then calculated relative to this `renderedImageContent` and its `contentOffset`, using `serverScale`.
    *   Added a basic check to hide the highlight if it's too small or completely off-screen.
4.  **`imgElement.onload` and `renderImage()` calls to `updateHighlightOverlay()`:**
    *   `updateHighlightOverlay()` is called in `imgElement.onload` to ensure the highlight is drawn/updated correctly once the new image tile is loaded and its effective dimensions are set.
    *   It's also called at the end of `renderImage()` to provide a more immediate update of the highlight's position during panning/zooming, even before the new image tile fully loads. This makes the highlight feel more responsive.
5.  **Zoom Logic Simplification Note:** The zoom-to-mouse-point logic in `setupEventListeners` still uses `currentScale` for its calculations. For perfect accuracy when letterboxing is present, it would ideally use the `serverScale` and `contentOffset` factors. However, `currentScale` is often a close enough approximation for good user experience, and making it perfectly accurate adds complexity. This is a potential area for further refinement if needed. The panning logic using `currentScale` for delta calculation is generally fine.
6.  **Minor Clamping Adjustment in `renderImage`**: Added a small check to ensure `reqWidthOrig` and `reqHeightOrig` are at least 1 after all clamping.

With these changes, the highlight rectangle should now correctly track its position and size relative to the underlying image content, regardless of panning, zooming, and aspect ratio differences between the image region and the viewport.

### USER
Excellent! Let’s add a wrinkle where users can supply multiple URNs, all referring to the same image, but with different ROI extensions. Form the IIIF request for a single image, but then overlay a rectangle for each ROI in the given URNs.  The rectangles should be drawn in different colors, and instead of outlining the rectangle they should be filled with a partly opaque overlay.

### ASSISTANT
Okay, this is a great extension to make the viewer more powerful for comparative analysis on a single image!

Here's the plan to accommodate multiple URNs for the same base image, each potentially with its own ROI, and render them as differently colored, semi-opaque filled rectangles:

1.  **Modify `createViewer` Signature**:
    *   It will now accept an array of CITE2 URN strings as the second parameter instead of a single string.
    *   The first URN in the array will be considered the "primary" URN for fetching image information and constructing IIIF requests. Its object ID will define the base image.

2.  **Update URN Parsing and ROI Storage**:
    *   `parseCite2Urn` will remain mostly the same, but it will be called for each URN in the input array.
    *   We'll store an array of `parsedUrn` objects.
    *   We'll need to validate that all URNs in the array (after stripping any `@roi` suffix) refer to the *same base image identifier*. If not, we should probably error out or only use the first one.

3.  **Manage Multiple Highlight Elements**:
    *   Instead of a single `highlightElement` and `roiOrigPx`, we'll have arrays: `highlightElements = []` and `roisOrigPxArray = []`.
    *   During initialization, after fetching `info.json` (based on the first URN), we'll iterate through all parsed URNs. For each one that has an ROI:
        *   Create a new `div` for its highlight.
        *   Assign it a unique color from a predefined list or a simple color generation scheme.
        *   Style it as a filled, semi-opaque rectangle (e.g., `background-color: rgba(R,G,B,0.3); border: none;`).
        *   Calculate its `roiOrigPx` and store it.

4.  **Update `updateHighlightOverlay` (or rename to `updateHighlightOverlays`)**:
    *   This function will now iterate through all `highlightElements` and their corresponding `roisOrigPxArray` entries.
    *   For each ROI, it will perform the same screen position and size calculations as before and update its respective `div`.

Here's the modified `hmt-iiif-viewer.js`:

**`hmt-iiif-viewer.js` (Multiple ROIs, Filled, Colored)**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    // Predefined distinct colors for ROIs
    const ROI_COLORS = [
        { r: 255, g: 0, b: 0 },    // Red
        { r: 0, g: 255, b: 0 },    // Green
        { r: 0, g: 0, b: 255 },    // Blue
        { r: 255, g: 255, b: 0 },  // Yellow
        { r: 255, g: 0, b: 255 },  // Magenta
        { r: 0, g: 255, b: 255 },  // Cyan
        { r: 255, g: 165, b: 0 },  // Orange
        { r: 128, g: 0, b: 128 },  // Purple
    ];
    const ROI_OPACITY = 0.3; // Opacity for filled ROIs

    function parseCite2Urn(urnString) {
        // ... (parseCite2Urn remains the same as in the previous correct version)
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString, // Keep original URN for reference if needed
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }

    function buildIIIFImageDataBase(parsedUrn) {
        // ... (buildIIIFImageDataBase remains the same)
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    // Takes an array of URN strings
    function createViewer(elementId, urnStrings) {
        const container = document.getElementById(elementId);
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        if (!Array.isArray(urnStrings) || urnStrings.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        container.style.cursor = 'grab';

        const imgElement = document.createElement('img');
        // ... (imgElement setup as before)
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        // Alt text from the first URN
        imgElement.alt = `IIIF image for ${urnStrings[0]}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        // ... (spinner setup as before)
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let highlightElements = []; // Array of DIVs for ROI highlights
        let roisData = [];          // Array of { roiOrigPx, colorString }

        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;

        let currentScale = 1.0;
        let centerXOrig = 0;
        let centerYOrig = 0;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        // Parse all URNs
        const parsedUrns = urnStrings.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        // Use the first valid URN to determine the base image for IIIF request
        const primaryParsedUrn = parsedUrns[0];
        const baseImageObjectId = primaryParsedUrn.objectId; // For checking consistency

        // Validate that all URNs (if multiple) refer to the same base image
        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list. All URNs must refer to the same image, differing only by ROI.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images. Please ensure all URNs identify the same image (differing only by ROI suffix).</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;
        
        imgElement.addEventListener('load', () => {
            spinner.style.display = 'none';
            updateHighlightOverlays();
        });
        imgElement.addEventListener('error', () => {
            spinner.style.display = 'none';
            container.innerHTML = `<p style="color:red;">Error loading image tile.</p>`;
        });

        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                // Initialize ROI highlights
                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const color = ROI_COLORS[index % ROI_COLORS.length];
                        const colorString = `rgba(${color.r}, ${color.g}, ${color.b}, ${ROI_OPACITY})`;

                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString; // Filled, semi-opaque
                        // No border for filled style, unless desired:
                        // highlightDiv.style.border = `2px solid rgba(${color.r}, ${color.g}, ${color.b}, ${ROI_OPACITY + 0.2})`;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);
                        highlightElements.push(highlightDiv);

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv // Keep a reference for direct manipulation
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => {
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() {
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }

        function updateHighlightOverlays() { // Renamed from updateHighlightOverlay
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0 ||
                lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0 || roisData.length === 0) {
                highlightElements.forEach(el => el.style.display = 'none');
                return;
            }

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }


        function renderImage() {
            // ... (renderImage logic to fetch and display image remains the same)
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays(); // Update all highlight overlays
        }

        // constrainState function remains the same
        function constrainState() {
            // ... (constrainState logic as before)
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        // setupEventListeners function remains largely the same
        function setupEventListeners() {
            // ... (setupEventListeners logic as before for zoom and pan)
            // Zoom
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            // Pan
            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return; 
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                container.style.cursor = 'grabbing';
                event.preventDefault();
            });

            container.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                centerXOrig -= dx / currentScale; 
                centerYOrig -= dy / currentScale;
                
                constrainState();
                scheduleRender();
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });
            
            // Resize
            window.addEventListener('resize', function() {
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        }
    } // End of createViewer

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Key Changes for Multiple ROIs:**

1.  **`ROI_COLORS` and `ROI_OPACITY`**: Constants defined at the top for styling.
2.  **`createViewer(elementId, urnStrings)`**: Now accepts an array `urnStrings`.
3.  **URN Parsing and Validation**:
    *   All URNs in `urnStrings` are parsed.
    *   The first URN (`primaryParsedUrn`) determines the base image for IIIF.
    *   A validation step ensures all subsequent URNs in the list refer to the *exact same base image* (namespace, collection, version, objectId before `@`). If not, an error is shown.
4.  **`highlightElements` and `roisData`**:
    *   `highlightElements` is now an array to hold the DOM elements for each ROI.
    *   `roisData` is an array of objects, where each object stores `{ roiOrigPx, element }`. This links the calculated original pixel ROI data to its DOM element.
5.  **ROI Initialization Loop**:
    *   Inside the `.then(info => ...)` block, after `imageInfo` is available.
    *   It iterates through `parsedUrns`. For each URN with an ROI:
        *   A color is picked from `ROI_COLORS` (cycling through if there are more ROIs than colors).
        *   A new `div` is created, styled with `background-color` (semi-opaque fill) and no border (or you can add one).
        *   It's added to `container` and `highlightElements`.
        *   The `roiOrigPx` and a reference to its `element` are stored in `roisData`.
6.  **`updateHighlightOverlays()` (plural)**:
    *   This function now iterates through the `roisData` array.
    *   For each `roiItem` (containing `roiOrigPx` and `element`), it performs the screen coordinate calculations and updates the style of `roiItem.element`.
    *   Called by `renderImage()` and `imgElement.onload`.
7.  **Alt Text**: The `imgElement.alt` text is taken from the first URN in the input array.

**To Test This with `interactive-test.html`:**

You'll need to modify your `interactive-test.html` to allow inputting multiple URNs (e.g., one URN per line in a `<textarea>`) and then pass them as an array to `HMTIIIFViewer.createViewer`.

Here's a quick modification to `interactive-test.html` for this:

**`interactive-test.html` (Modified for Multiple URNs)**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive HMT IIIF Viewer Test (Multiple ROIs)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column; /* Stack label and textarea */
            gap: 10px;
            align-items: stretch; /* Make children stretch */
            width: 80vw;
            max-width: 700px;
        }
        .controls label {
            font-weight: bold;
        }
        .controls textarea { /* Changed from input to textarea */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 80px; /* For multiple lines */
            font-family: monospace; /* Good for URNs */
        }
        .controls button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-start; /* Align button to the start if controls are wider */
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .viewer-container {
            width: 80vw;
            max-width: 800px;
            height: 60vh;
            max-height: 600px;
            border: 1px solid #ccc;
            background-color: #e9e9e9;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }
        #viewer-status {
            margin-top: 10px;
            font-style: italic;
            color: #555;
        }
    </style>
</head>
<body>
    <h1>Interactive Homer Multitext IIIF Viewer (Multiple ROIs)</h1>

    <div class="controls">
        <label for="urnInput">CITE2 URNs (one per line):</label>
        <textarea id="urnInput">urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.3,0.3
urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.6,0.6,0.25,0.25
urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.2,0.5,0.4,0.15</textarea>
        <button id="loadButton">Load Image(s) with ROIs</button>
    </div>

    <div id="imageViewer" class="viewer-container">
        <!-- The IIIF viewer will be rendered here -->
    </div>
    <div id="viewer-status">Enter HMT CITE2 URNs (one per line) and click "Load".</div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInputElement = document.getElementById('urnInput');
            const loadButtonElement = document.getElementById('loadButton');
            const viewerContainerId = 'imageViewer';
            const statusElement = document.getElementById('viewer-status');

            function loadImageViewer() {
                const urnText = urnInputElement.value.trim();
                if (urnText) {
                    // Split by newline, filter out empty lines, and trim whitespace
                    const urnArray = urnText.split('\n')
                                          .map(urn => urn.trim())
                                          .filter(urn => urn.length > 0);

                    if (urnArray.length > 0) {
                        statusElement.textContent = `Loading URNs...`;
                        HMTIIIFViewer.createViewer(viewerContainerId, urnArray);
                    } else {
                        statusElement.textContent = 'Please enter at least one valid URN.';
                        document.getElementById(viewerContainerId).innerHTML = '<p style="color:orange;">Please enter URNs.</p>';
                    }
                } else {
                    statusElement.textContent = 'Please enter URNs.';
                    document.getElementById(viewerContainerId).innerHTML = '<p style="color:orange;">Please enter URNs.</p>';
                }
            }

            loadButtonElement.addEventListener('click', loadImageViewer);

            // Load the default URNs when the page loads
            statusElement.textContent = `Loading default URNs...`;
            loadImageViewer(); // Call it to load defaults
        });
    </script>

</body>
</html>
```
Now, when you open `interactive-test.html`, it will load the default URNs (which you can modify in the `<textarea>`), parse them, fetch the single base image, and overlay the three ROIs with different semi-opaque filled colors.

### USER
This works perfectly when the user supplies an array of URN values, but no longer supports creating a viewer with a single URN string as it did before. Could we modify this to support both?

### ASSISTANT
You're right, that's a good point for backward compatibility and ease of use for the single URN case!

We can easily modify the `createViewer` function to check the type of the second argument. If it's a string, we'll internally convert it to an array with a single element.

Here's the updated `createViewer` function within `hmt-iiif-viewer.js`:

**`hmt-iiif-viewer.js` (Modified `createViewer` for flexible input)**
```javascript
(function(window) {
    'use strict';

    // ... (HMT_IIIF_PROTOCOL, HMT_IIIF_SERVER_BASE, HMT_IIIF_PATH_BASE, ROI_COLORS, ROI_OPACITY as before)
    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    const ROI_COLORS = [
        { r: 255, g: 0, b: 0 },    // Red
        { r: 0, g: 255, b: 0 },    // Green
        { r: 0, g: 0, b: 255 },    // Blue
        { r: 255, g: 255, b: 0 },  // Yellow
        { r: 255, g: 0, b: 255 },  // Magenta
        { r: 0, g: 255, b: 255 },  // Cyan
        { r: 255, g: 165, b: 0 },  // Orange
        { r: 128, g: 0, b: 128 },  // Purple
    ];
    const ROI_OPACITY = 0.3;

    function parseCite2Urn(urnString) {
        // ... (parseCite2Urn remains the same)
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString,
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }

    function buildIIIFImageDataBase(parsedUrn) {
        // ... (buildIIIFImageDataBase remains the same)
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    // Accepts a single URN string OR an array of URN strings
    function createViewer(elementId, urnInput) { // Renamed second param to urnInput
        const container = document.getElementById(elementId);
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        let urnStringsArray;
        if (typeof urnInput === 'string') {
            urnStringsArray = [urnInput];
        } else if (Array.isArray(urnInput)) {
            urnStringsArray = urnInput;
        } else {
            container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
            return;
        }

        if (urnStringsArray.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        // Clear container and basic setup
        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        container.style.cursor = 'grab';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${urnStringsArray[0]}`; // Alt text from the first URN
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let highlightElements = [];
        let roisData = [];

        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;

        let currentScale = 1.0;
        let centerXOrig = 0;
        let centerYOrig = 0;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        const parsedUrns = urnStringsArray.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        const primaryParsedUrn = parsedUrns[0];
        const baseImageObjectId = primaryParsedUrn.objectId;

        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images.</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;
        
        imgElement.addEventListener('load', () => {
            spinner.style.display = 'none';
            updateHighlightOverlays();
        });
        imgElement.addEventListener('error', () => {
            spinner.style.display = 'none';
            container.innerHTML = `<p style="color:red;">Error loading image tile.</p>`;
        });

        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const color = ROI_COLORS[index % ROI_COLORS.length];
                        const colorString = `rgba(${color.r}, ${color.g}, ${color.b}, ${ROI_OPACITY})`;
                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);
                        // highlightElements.push(highlightDiv); // Not strictly needed if using roisData.element

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => {
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() {
            // ... (scheduleRender remains the same)
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }

        function updateHighlightOverlays() {
            // ... (updateHighlightOverlays remains the same)
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0 ||
                lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0 || roisData.length === 0) {
                // Ensure all potential old highlight elements are hidden if no roisData
                roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                return;
            }

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }

        function renderImage() {
            // ... (renderImage remains the same)
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays();
        }

        function constrainState() {
            // ... (constrainState remains the same)
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        function setupEventListeners() {
            // ... (setupEventListeners remains the same)
             // Zoom
             container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            // Pan
            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return; 
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                container.style.cursor = 'grabbing';
                event.preventDefault();
            });

            container.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                centerXOrig -= dx / currentScale; 
                centerYOrig -= dy / currentScale;
                
                constrainState();
                scheduleRender();
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDragging) {
                    isDragging = false;
                    container.style.cursor = 'grab';
                }
            });
            
            // Resize
            window.addEventListener('resize', function() {
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        }
    } // End of createViewer

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Changes Made:**

1.  **`createViewer(elementId, urnInput)`**: The second parameter is now named `urnInput` to reflect its flexible nature.
2.  **Type Check and Conversion**:
    ```javascript
    let urnStringsArray;
    if (typeof urnInput === 'string') {
        urnStringsArray = [urnInput]; // Convert single string to array
    } else if (Array.isArray(urnInput)) {
        urnStringsArray = urnInput;   // Use array as is
    } else {
        // Handle invalid input type
        container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
        return;
    }

    if (urnStringsArray.length === 0) {
        // Handle empty array case (even if a valid empty array was passed)
        container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
        return;
    }
    ```
    This block now correctly prepares `urnStringsArray` for the rest of the function, regardless of whether a single string or an array was passed.
3.  **`highlightElements.push(highlightDiv)`**: I noticed this line was still present in the `parsedUrns.forEach` loop but `highlightElements` itself isn't directly used later if `roisData` stores the element. I've commented it out as `roisData[i].element` is the primary way to access the highlight divs. It doesn't harm anything to keep it, but it's redundant.
4.  **`updateHighlightOverlays()` robustness**: Added a small check to ensure all highlight elements are hidden if `roisData` is empty, just in case.

Now, your `test.html` (the one with two viewers) should work again if you call:
`HMTIIIFViewer.createViewer('viewer1', 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013');`

And your `interactive-test.html` (with the textarea) will continue to work by passing an array. This provides the desired flexibility.

### USER
Fantastic! Would it be possible to implement a separate interaction mode when the control key is held down where (1) pan and zoom are disabled, (2) clicking and dragging allows the user to draw a highlighted rectangle on the image, and (3) the coordinates of the user-drawn rectangle are returned to a listener function? Is so, please write an HTML example that displays a list of coordinates for user-drawn rectangles. The coordinates should be returned in the same format as the URN extension, i.e. @x,y,w,h where x,y,w,h are all expressed as percentages from 0 to 1, and appended to the URN for the example.  The return value should be a list of these URNs separated by newline characters, so that the user can draw multiple rectangles and get a single string of coordinates back.  The user should be able to draw multiple rectangles, and the coordinates of each rectangle should be returned in a single multiline string, one URN per line.

### ASSISTANT
This is a great interactive feature! We'll add a "draw mode" activated by holding the Control key.

Here's the plan:

1.  **State for Draw Mode**:
    *   Add a `isControlKeyDown` flag, updated by `keydown` and `keyup` event listeners on the `window` (or `container` if focus is guaranteed).
    *   Add `isDrawingRectangle` flag.
    *   Store `drawStartX`, `drawStartY` (in viewport coordinates) when a draw starts.

2.  **Modify Event Handlers in `createViewer`**:
    *   **`mousedown`**:
        *   If `isControlKeyDown` is true, prevent default pan, set `isDrawingRectangle = true`, and record `drawStartX`, `drawStartY`. Create a temporary visual feedback `div` for the rectangle being drawn.
        *   Else, proceed with panning.
    *   **`mousemove`**:
        *   If `isDrawingRectangle` and `isControlKeyDown` are true, update the size and position of the temporary drawing rectangle `div`.
        *   Else, proceed with panning if `isDragging`.
    *   **`mouseup`**:
        *   If `isDrawingRectangle` and `isControlKeyDown` are true:
            *   Finalize the rectangle.
            *   Convert its screen coordinates to original image percentage coordinates (`x,y,w,h` from 0-1).
            *   Call a listener function provided during viewer creation, passing the new ROI string (`@x,y,w,h`).
            *   Remove the temporary drawing rectangle `div`.
            *   Reset `isDrawingRectangle = false`.
        *   Else, proceed with ending pan.
    *   **`wheel`**: Disable zoom if `isControlKeyDown` is true.

3.  **Listener Function**:
    *   `createViewer` will accept an optional third argument: `onRoiDrawnCallback(roiString)`.

4.  **Coordinate Conversion**: This is the trickiest part. When the user finishes drawing a rectangle in screen coordinates, we need to:
    *   Convert its top-left corner and its bottom-right corner from screen coordinates (relative to the viewport/container) to coordinates on the *original, full-resolution image*.
    *   This requires knowing:
        *   `lastRequestedRegion`: The `{x, y, w, h}` of the original image currently being displayed.
        *   `serverScale`: The scale factor applied by the IIIF server to `lastRequestedRegion` to fit it into the viewport.
        *   `contentOffsetX`, `contentOffsetY`: The offsets of the displayed image content within the viewport (due to `object-fit: contain`).
    *   Once we have the `x_orig, y_orig, w_orig, h_orig` in original image pixels, convert them to percentages: `x_pct = x_orig / imageInfo.width`, etc.

5.  **HTML Example (`roi-draw-test.html`)**:
    *   Will initialize a viewer with a callback function.
    *   The callback will append the new ROI URN string (base URN + `@x,y,w,h`) to a `<textarea>`.
    *   Will display the base URN used for drawing.

Let's implement this.

**`hmt-iiif-viewer.js` (with Draw Mode)**
```javascript
(function(window) {
    'use strict';

    // ... (Constants: HMT_IIIF_PROTOCOL, SERVER_BASE, PATH_BASE, ROI_COLORS, ROI_OPACITY as before)
    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    const ROI_COLORS = [ /* ... as before ... */ { r: 255, g: 0, b: 0 },{ r: 0, g: 255, b: 0 },{ r: 0, g: 0, b: 255 },{ r: 255, g: 255, b: 0 },{ r: 255, g: 0, b: 255 },{ r: 0, g: 255, b: 255 },{ r: 255, g: 165, b: 0 },{ r: 128, g: 0, b: 128 }];
    const ROI_OPACITY = 0.3;


    function parseCite2Urn(urnString) { /* ... as before ... */ 
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
             console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString,
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }
    function buildIIIFImageDataBase(parsedUrn) { /* ... as before ... */ 
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    // Accepts URN input and an optional callback for drawn ROIs
    function createViewer(elementId, urnInput, onRoiDrawnCallback) {
        const container = document.getElementById(elementId);
        // ... (Initial checks for container, urnInput, urnStringsArray setup as before)
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        let urnStringsArray;
        if (typeof urnInput === 'string') {
            urnStringsArray = [urnInput];
        } else if (Array.isArray(urnInput)) {
            urnStringsArray = urnInput;
        } else {
            container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
            return;
        }

        if (urnStringsArray.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        // container.style.cursor = 'grab'; // Will be managed dynamically

        const imgElement = document.createElement('img');
        // ... (imgElement setup as before)
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${urnStringsArray[0]}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        // ... (spinner setup as before)
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);


        // State variables
        let roisData = [];
        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;
        let currentScale = 1.0;
        let centerXOrig = 0, centerYOrig = 0;
        let isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        // Draw mode state
        let isControlKeyDown = false;
        let isDrawingRectangle = false;
        let drawStartX = 0, drawStartY = 0; // Viewport coordinates
        let tempDrawRectElement = null;
        let baseUrnForDrawing = ''; // URN string without ROI part

        const parsedUrns = urnStringsArray.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        // ... (Validation of parsedUrns, primaryParsedUrn, baseImageObjectId, iiifImageDataPath, infoUrl as before)
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        const primaryParsedUrn = parsedUrns[0];
        baseUrnForDrawing = `${primaryParsedUrn.urn.split('@')[0]}`; // Store base URN for drawing mode
        const baseImageObjectId = primaryParsedUrn.objectId;

        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images.</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;


        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                // ... (Initialize existing ROIs, centerXOrig, centerYOrig, currentScale as before)
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const color = ROI_COLORS[index % ROI_COLORS.length];
                        const colorString = `rgba(${color.r}, ${color.g}, ${color.b}, ${ROI_OPACITY})`;
                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners(); // Setup all event listeners now
            })
            .catch(error => { /* ... */ });

        function scheduleRender() { /* ... as before ... */ 
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }
        function updateHighlightOverlays() { /* ... as before ... */ 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0 ||
                lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0 || roisData.length === 0) {
                roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                return;
            }

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }
        function renderImage() { /* ... as before ... */ 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays();
        }
        function constrainState() { /* ... as before ... */ 
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        // Helper to convert screen coordinates to original image percentage coordinates
        function screenRectToImagePct(screenX, screenY, screenW, screenH) {
            if (!imageInfo || lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) return null;

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            // Convert screen coordinates relative to the actual image content
            const x1_on_content_screen = screenX - contentOffsetX;
            const y1_on_content_screen = screenY - contentOffsetY;
            const x2_on_content_screen = screenX + screenW - contentOffsetX;
            const y2_on_content_screen = screenY + screenH - contentOffsetY;
            
            // Convert these to coordinates on the *requested region* of original image
            const x1_on_region_orig = x1_on_content_screen / serverScale;
            const y1_on_region_orig = y1_on_content_screen / serverScale;
            const x2_on_region_orig = x2_on_content_screen / serverScale;
            const y2_on_region_orig = y2_on_content_screen / serverScale;

            // Convert to coordinates on the *full original image*
            let roi_x_orig = finalReqX + x1_on_region_orig;
            let roi_y_orig = finalReqY + y1_on_region_orig;
            let roi_x2_orig = finalReqX + x2_on_region_orig;
            let roi_y2_orig = finalReqY + y2_on_region_orig;

            // Ensure x,y is top-left and w,h are positive
            let roi_w_orig = Math.abs(roi_x2_orig - roi_x_orig);
            let roi_h_orig = Math.abs(roi_y2_orig - roi_y_orig);
            roi_x_orig = Math.min(roi_x_orig, roi_x2_orig);
            roi_y_orig = Math.min(roi_y_orig, roi_y2_orig);


            // Clamp to image boundaries (0 to imageInfo.width/height)
            roi_x_orig = Math.max(0, Math.min(roi_x_orig, imageInfo.width));
            roi_y_orig = Math.max(0, Math.min(roi_y_orig, imageInfo.height));
            
            // Adjust width/height if x/y were clamped or if x2/y2 goes out of bounds
            roi_w_orig = Math.min(roi_w_orig, imageInfo.width - roi_x_orig);
            roi_h_orig = Math.min(roi_h_orig, imageInfo.height - roi_y_orig);

            if (roi_w_orig <= 0 || roi_h_orig <= 0) return null; // Invalid rect

            // Convert to percentage
            const pctX = roi_x_orig / imageInfo.width;
            const pctY = roi_y_orig / imageInfo.height;
            const pctW = roi_w_orig / imageInfo.width;
            const pctH = roi_h_orig / imageInfo.height;

            // Format to a few decimal places for cleanliness
            return {
                x: parseFloat(pctX.toFixed(4)),
                y: parseFloat(pctY.toFixed(4)),
                w: parseFloat(pctW.toFixed(4)),
                h: parseFloat(pctH.toFixed(4))
            };
        }


        function setupEventListeners() {
            // Control key state
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Control') {
                    isControlKeyDown = true;
                    if(!isDrawingRectangle) container.style.cursor = 'crosshair';
                }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Control') {
                    isControlKeyDown = false;
                    if(!isDrawingRectangle && !isDragging) container.style.cursor = 'grab';
                }
            });

            // Wheel for Zoom
            container.addEventListener('wheel', function(event) {
                if (isControlKeyDown) {
                    event.preventDefault(); // Prevent zoom when Ctrl is down
                    return;
                }
                // ... (rest of zoom logic as before)
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            // Mousedown for Pan or Draw
            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return; // Only left click
                event.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isControlKeyDown) {
                    isDrawingRectangle = true;
                    drawStartX = mouseXvp;
                    drawStartY = mouseYvp;

                    if (tempDrawRectElement) tempDrawRectElement.remove(); // Remove old if any
                    tempDrawRectElement = document.createElement('div');
                    tempDrawRectElement.style.position = 'absolute';
                    tempDrawRectElement.style.border = '2px dashed blue';
                    tempDrawRectElement.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    tempDrawRectElement.style.left = `${drawStartX}px`;
                    tempDrawRectElement.style.top = `${drawStartY}px`;
                    tempDrawRectElement.style.width = '0px';
                    tempDrawRectElement.style.height = '0px';
                    tempDrawRectElement.style.pointerEvents = 'none';
                    container.appendChild(tempDrawRectElement);
                    container.style.cursor = 'crosshair';
                } else {
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    container.style.cursor = 'grabbing';
                }
            });

            // Mousemove for Pan or Draw
            container.addEventListener('mousemove', function(event) {
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isDrawingRectangle && isControlKeyDown) {
                    if (tempDrawRectElement) {
                        const currentX = mouseXvp;
                        const currentY = mouseYvp;
                        const newX = Math.min(drawStartX, currentX);
                        const newY = Math.min(drawStartY, currentY);
                        const newW = Math.abs(drawStartX - currentX);
                        const newH = Math.abs(drawStartY - currentY);
                        tempDrawRectElement.style.left = `${newX}px`;
                        tempDrawRectElement.style.top = `${newY}px`;
                        tempDrawRectElement.style.width = `${newW}px`;
                        tempDrawRectElement.style.height = `${newH}px`;
                    }
                } else if (isDragging) {
                    // ... (pan logic as before)
                    const dx = event.clientX - lastMouseX;
                    const dy = event.clientY - lastMouseY;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;

                    centerXOrig -= dx / currentScale; 
                    centerYOrig -= dy / currentScale;
                    
                    constrainState();
                    scheduleRender();
                }
            });

            // Mouseup for Pan or Draw
            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;

                if (isDrawingRectangle && isControlKeyDown) {
                    if (tempDrawRectElement) {
                        const rect = tempDrawRectElement.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        const finalDrawX = rect.left - containerRect.left;
                        const finalDrawY = rect.top - containerRect.top;
                        const finalDrawW = rect.width;
                        const finalDrawH = rect.height;

                        if (finalDrawW > 2 && finalDrawH > 2) { // Min size for a valid rect
                            const roiPct = screenRectToImagePct(finalDrawX, finalDrawY, finalDrawW, finalDrawH);
                            if (roiPct && typeof onRoiDrawnCallback === 'function') {
                                const roiString = `@${roiPct.x},${roiPct.y},${roiPct.w},${roiPct.h}`;
                                onRoiDrawnCallback(baseUrnForDrawing + roiString);
                            }
                        }
                        tempDrawRectElement.remove();
                        tempDrawRectElement = null;
                    }
                    isDrawingRectangle = false;
                    // Cursor management: if Ctrl still down, keep crosshair, else grab
                    container.style.cursor = isControlKeyDown ? 'crosshair' : 'grab';
                } else if (isDragging) {
                    isDragging = false;
                    container.style.cursor = isControlKeyDown ? 'crosshair' : 'grab';
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDrawingRectangle) { // If mouse leaves while drawing, cancel it
                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = null;
                    isDrawingRectangle = false;
                }
                if (isDragging) {
                    isDragging = false;
                }
                container.style.cursor = isControlKeyDown ? 'crosshair' : 'grab';
            });

            // Initial cursor
            container.style.cursor = 'grab';
             // Window resize listener
             window.addEventListener('resize', function() { /* ... as before ... */ 
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        } // End of setupEventListeners
    } // End of createViewer

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Key Changes in `hmt-iiif-viewer.js`:**

1.  **`createViewer(elementId, urnInput, onRoiDrawnCallback)`**: Added optional `onRoiDrawnCallback`.
2.  **Draw Mode State**: `isControlKeyDown`, `isDrawingRectangle`, `drawStartX/Y`, `tempDrawRectElement`, `baseUrnForDrawing`.
3.  **`baseUrnForDrawing`**: Stored from the first URN, stripped of any existing ROI, to be used for new ROI strings.
4.  **`screenRectToImagePct` Function**: This new helper does the crucial conversion from screen rectangle coordinates to image percentage coordinates. It uses `lastRequestedRegion`, `serverScale`, and `contentOffset` for accuracy.
5.  **Event Listener Modifications (`setupEventListeners`)**:
    *   **`window` keydown/keyup**: Manage `isControlKeyDown` and cursor style.
    *   **`container` wheel**: If `isControlKeyDown`, prevent default zoom.
    *   **`container` mousedown**:
        *   If Ctrl: Start drawing mode, create `tempDrawRectElement`.
        *   Else: Start pan.
    *   **`container` mousemove**:
        *   If drawing: Update `tempDrawRectElement` size/position.
        *   Else if panning: Pan.
    *   **`container` mouseup**:
        *   If drawing: Finalize, convert rect using `screenRectToImagePct`, call `onRoiDrawnCallback`, remove `tempDrawRectElement`.
        *   Else if panning: End pan.
    *   **`container` mouseleave**: Cancels drawing if active, resets cursor.
    *   Cursor management to switch between 'grab' and 'crosshair'.

---

**`roi-draw-test.html` (HTML Example)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIIF Viewer - ROI Drawing Test</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; padding: 10px; background-color: #f0f0f0; border-radius: 5px; width: 80%; max-width: 700px;}
        .controls label { display: block; margin-bottom: 5px; font-weight: bold; }
        .controls input[type="text"] { width: calc(100% - 22px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .controls textarea { width: calc(100% - 22px); min-height: 100px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
        .viewer-container {
            width: 70vw;
            max-width: 700px;
            height: 50vh;
            max-height: 500px;
            border: 1px solid #ccc;
            background-color: #e9e9e9;
            margin-bottom: 20px;
        }
        #instructions { margin-bottom:15px; padding:10px; background-color: #eef; border: 1px solid #ccf; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>IIIF Viewer - ROI Drawing Test</h1>

    <div id="instructions">
        <p>Hold <strong>Ctrl</strong> key and then click and drag on the image to draw a rectangle. Release the mouse button to finalize the ROI. Pan and zoom are disabled while Ctrl is held.</p>
    </div>

    <div class="controls">
        <label for="urnInput">Base Image URN:</label>
        <input type="text" id="urnInput" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013">
        <button id="loadButton">Load Image</button>
    </div>

    <div id="imageViewer" class="viewer-container"></div>

    <div class="controls">
        <label for="drawnRois">Drawn ROIs (URN@x,y,w,h format):</label>
        <textarea id="drawnRois" readonly></textarea>
        <button id="clearRoisButton">Clear Drawn ROIs List</button>
    </div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInputElement = document.getElementById('urnInput');
            const loadButtonElement = document.getElementById('loadButton');
            const viewerContainerId = 'imageViewer';
            const drawnRoisTextarea = document.getElementById('drawnRois');
            const clearRoisButton = document.getElementById('clearRoisButton');

            let currentViewerInstance = null; // To manage re-creating the viewer

            function handleNewRoi(roiUrnString) {
                drawnRoisTextarea.value += roiUrnString + '\n';
            }

            function loadImageViewer() {
                const baseUrn = urnInputElement.value.trim();
                if (baseUrn) {
                    // If you want to also display pre-existing ROIs from the input, parse them here.
                    // For this example, we'll just load the base image for drawing.
                    // The createViewer function itself can handle URNs with ROIs if passed.
                    // To keep it simple for drawing, we pass just the base URN.
                    // Or, if urnInputElement can contain URNs with ROIs to *display*, parse them.
                    // For now, assume urnInputElement is the base for drawing and initial display.
                    
                    // Clear previous viewer if any
                    document.getElementById(viewerContainerId).innerHTML = 'Loading...';


                    HMTIIIFViewer.createViewer(viewerContainerId, baseUrn, handleNewRoi);
                } else {
                    document.getElementById(viewerContainerId).innerHTML = '<p style="color:red;">Please enter a base URN.</p>';
                }
            }

            loadButtonElement.addEventListener('click', loadImageViewer);
            clearRoisButton.addEventListener('click', () => {
                drawnRoisTextarea.value = '';
            });

            // Load default image on page load
            loadImageViewer();
        });
    </script>
</body>
</html>
```

Now, when you load `roi-draw-test.html`:
1.  The default image loads.
2.  Hold down the Control key. The cursor should change to a crosshair over the viewer.
3.  While Ctrl is down, click and drag on the image. A temporary blue dashed rectangle will appear.
4.  Release the mouse button (while Ctrl is still held or released just after).
5.  The URN for the drawn rectangle (e.g., `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.2345,0.4567,0.1000,0.0500`) will be appended to the "Drawn ROIs" textarea.
6.  You can draw multiple rectangles this way.

This provides a powerful way for users to interactively define regions of interest!

### USER
I'm getting some interferecne with other key mappings for control key. Could we change the key mapping to use the option key instead of the control key?  Please update the code to reflect this change.

### ASSISTANT
You're right, the Control key can often have system-level or browser-level shortcuts that might interfere. The Option key (often labeled Alt on non-Mac keyboards) is a good alternative.

Here are the necessary changes:

**1. Update `hmt-iiif-viewer.js`**

We'll change `isControlKeyDown` to `isAltKeyDown` and check for `event.key === 'Alt'`. We also need to add `event.preventDefault()` in the `keydown` listener for 'Alt' to prevent default browser actions like focusing the menu bar.

```javascript
(function(window) {
    'use strict';

    // ... (Constants: HMT_IIIF_PROTOCOL, SERVER_BASE, PATH_BASE, ROI_COLORS, ROI_OPACITY as before)
    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    const ROI_COLORS = [ /* ... as before ... */ { r: 255, g: 0, b: 0 },{ r: 0, g: 255, b: 0 },{ r: 0, g: 0, b: 255 },{ r: 255, g: 255, b: 0 },{ r: 255, g: 0, b: 255 },{ r: 0, g: 255, b: 255 },{ r: 255, g: 165, b: 0 },{ r: 128, g: 0, b: 128 }];
    const ROI_OPACITY = 0.3;


    function parseCite2Urn(urnString) { /* ... as before ... */ 
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            // console.error("Invalid CITE2 URN format:", urnString); // Keep console logs for debugging
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
            //  console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    // console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                // console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString,
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }
    function buildIIIFImageDataBase(parsedUrn) { /* ... as before ... */ 
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    function createViewer(elementId, urnInput, onRoiDrawnCallback) {
        const container = document.getElementById(elementId);
        // ... (Initial checks for container, urnInput, urnStringsArray setup as before)
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        let urnStringsArray;
        if (typeof urnInput === 'string') {
            urnStringsArray = [urnInput];
        } else if (Array.isArray(urnInput)) {
            urnStringsArray = urnInput;
        } else {
            container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
            return;
        }

        if (urnStringsArray.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';
        // container.style.cursor will be managed dynamically

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${urnStringsArray[0]}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);


        // State variables
        let roisData = [];
        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;
        let currentScale = 1.0;
        let centerXOrig = 0, centerYOrig = 0;
        let isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        // Draw mode state
        let isAltKeyDown = false; // CHANGED from isControlKeyDown
        let isDrawingRectangle = false;
        let drawStartX = 0, drawStartY = 0;
        let tempDrawRectElement = null;
        let baseUrnForDrawing = '';

        const parsedUrns = urnStringsArray.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        // ... (Validation of parsedUrns, primaryParsedUrn, baseImageObjectId, iiifImageDataPath, infoUrl as before)
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        const primaryParsedUrn = parsedUrns[0];
        baseUrnForDrawing = `${primaryParsedUrn.urn.split('@')[0]}`;
        const baseImageObjectId = primaryParsedUrn.objectId;

        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images.</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;


        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const color = ROI_COLORS[index % ROI_COLORS.length];
                        const colorString = `rgba(${color.r}, ${color.g}, ${color.b}, ${ROI_OPACITY})`;
                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => { 
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() { /* ... as before ... */ 
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }
        function updateHighlightOverlays() { /* ... as before ... */ 
             if (!imageInfo || viewportWidth === 0 || viewportHeight === 0 || roisData.length === 0) { // Simplified condition if lastRequestedRegion not essential here
                roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                if (roisData.length === 0 && lastRequestedRegion.w <=0) return; // Exit if no ROIs and image not ready for region calculation
            }
            // Ensure lastRequestedRegion is valid if we proceed with calculations based on it
             if (lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) {
                 roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                 return;
             }


            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }
        function renderImage() { /* ... as before ... */ 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays();
        }
        function constrainState() { /* ... as before ... */ 
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }

        function screenRectToImagePct(screenX, screenY, screenW, screenH) { /* ... as before ... */ 
            if (!imageInfo || lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) return null;

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            const x1_on_content_screen = screenX - contentOffsetX;
            const y1_on_content_screen = screenY - contentOffsetY;
            const x2_on_content_screen = screenX + screenW - contentOffsetX;
            const y2_on_content_screen = screenY + screenH - contentOffsetY;
            
            const x1_on_region_orig = x1_on_content_screen / serverScale;
            const y1_on_region_orig = y1_on_content_screen / serverScale;
            const x2_on_region_orig = x2_on_content_screen / serverScale;
            const y2_on_region_orig = y2_on_content_screen / serverScale;

            let roi_x_orig = finalReqX + x1_on_region_orig;
            let roi_y_orig = finalReqY + y1_on_region_orig;
            let roi_x2_orig = finalReqX + x2_on_region_orig;
            let roi_y2_orig = finalReqY + y2_on_region_orig;

            let roi_w_orig = Math.abs(roi_x2_orig - roi_x_orig);
            let roi_h_orig = Math.abs(roi_y2_orig - roi_y_orig);
            roi_x_orig = Math.min(roi_x_orig, roi_x2_orig);
            roi_y_orig = Math.min(roi_y_orig, roi_y2_orig);

            roi_x_orig = Math.max(0, Math.min(roi_x_orig, imageInfo.width));
            roi_y_orig = Math.max(0, Math.min(roi_y_orig, imageInfo.height));
            
            roi_w_orig = Math.min(roi_w_orig, imageInfo.width - roi_x_orig);
            roi_h_orig = Math.min(roi_h_orig, imageInfo.height - roi_y_orig);

            if (roi_w_orig <= 0 || roi_h_orig <= 0) return null;

            const pctX = roi_x_orig / imageInfo.width;
            const pctY = roi_y_orig / imageInfo.height;
            const pctW = roi_w_orig / imageInfo.width;
            const pctH = roi_h_orig / imageInfo.height;

            return {
                x: parseFloat(pctX.toFixed(4)),
                y: parseFloat(pctY.toFixed(4)),
                w: parseFloat(pctW.toFixed(4)),
                h: parseFloat(pctH.toFixed(4))
            };
        }


        function setupEventListeners() {
            // Alt key state (Option key on Mac)
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Alt') {
                    event.preventDefault(); // IMPORTANT: Prevents default Alt key actions (e.g. menu focus)
                    isAltKeyDown = true; // CHANGED
                    if(!isDrawingRectangle) container.style.cursor = 'crosshair';
                }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Alt') {
                    // No need for event.preventDefault() on keyup usually
                    isAltKeyDown = false; // CHANGED
                    if(!isDrawingRectangle && !isDragging) container.style.cursor = 'grab';
                }
            });

            container.addEventListener('wheel', function(event) {
                if (isAltKeyDown) { // CHANGED
                    event.preventDefault(); 
                    return;
                }
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            container.addEventListener('mousedown', function(event) {
                if (event.button !== 0) return;
                event.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isAltKeyDown) { // CHANGED
                    isDrawingRectangle = true;
                    drawStartX = mouseXvp;
                    drawStartY = mouseYvp;

                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = document.createElement('div');
                    tempDrawRectElement.style.position = 'absolute';
                    tempDrawRectElement.style.border = '2px dashed blue';
                    tempDrawRectElement.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    tempDrawRectElement.style.left = `${drawStartX}px`;
                    tempDrawRectElement.style.top = `${drawStartY}px`;
                    tempDrawRectElement.style.width = '0px';
                    tempDrawRectElement.style.height = '0px';
                    tempDrawRectElement.style.pointerEvents = 'none';
                    container.appendChild(tempDrawRectElement);
                    container.style.cursor = 'crosshair';
                } else {
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    container.style.cursor = 'grabbing';
                }
            });

            container.addEventListener('mousemove', function(event) {
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isDrawingRectangle && isAltKeyDown) { // CHANGED
                    if (tempDrawRectElement) {
                        const currentX = mouseXvp;
                        const currentY = mouseYvp;
                        const newX = Math.min(drawStartX, currentX);
                        const newY = Math.min(drawStartY, currentY);
                        const newW = Math.abs(drawStartX - currentX);
                        const newH = Math.abs(drawStartY - currentY);
                        tempDrawRectElement.style.left = `${newX}px`;
                        tempDrawRectElement.style.top = `${newY}px`;
                        tempDrawRectElement.style.width = `${newW}px`;
                        tempDrawRectElement.style.height = `${newH}px`;
                    }
                } else if (isDragging) {
                    const dx = event.clientX - lastMouseX;
                    const dy = event.clientY - lastMouseY;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;

                    centerXOrig -= dx / currentScale; 
                    centerYOrig -= dy / currentScale;
                    
                    constrainState();
                    scheduleRender();
                }
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;

                if (isDrawingRectangle && isAltKeyDown) { // CHANGED
                    if (tempDrawRectElement) {
                        const rect = tempDrawRectElement.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        const finalDrawX = rect.left - containerRect.left;
                        const finalDrawY = rect.top - containerRect.top;
                        const finalDrawW = rect.width;
                        const finalDrawH = rect.height;

                        if (finalDrawW > 2 && finalDrawH > 2) {
                            const roiPct = screenRectToImagePct(finalDrawX, finalDrawY, finalDrawW, finalDrawH);
                            if (roiPct && typeof onRoiDrawnCallback === 'function') {
                                const roiString = `@${roiPct.x},${roiPct.y},${roiPct.w},${roiPct.h}`;
                                onRoiDrawnCallback(baseUrnForDrawing + roiString);
                            }
                        }
                        tempDrawRectElement.remove();
                        tempDrawRectElement = null;
                    }
                    isDrawingRectangle = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab'; // CHANGED
                } else if (isDragging) {
                    isDragging = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab'; // CHANGED
                }
            });

            container.addEventListener('mouseleave', function() {
                if (isDrawingRectangle) {
                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = null;
                    isDrawingRectangle = false;
                }
                if (isDragging) {
                    isDragging = false;
                }
                container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab'; // CHANGED
            });

            container.style.cursor = 'grab'; // Initial cursor
            
            window.addEventListener('resize', function() { /* ... as before ... */ 
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        } 
    } 

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Summary of changes in `hmt-iiif-viewer.js`:**
*   Replaced `isControlKeyDown` with `isAltKeyDown`.
*   Changed key check from `'Control'` to `'Alt'`.
*   Added `event.preventDefault()` to the `keydown` listener for `'Alt'` to stop default browser behaviors (like focusing the menu bar).
*   Updated all conditional logic that used `isControlKeyDown` to now use `isAltKeyDown`.

**2. Update `roi-draw-test.html`**

Only the instructional text needs to be changed.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIIF Viewer - ROI Drawing Test (Alt/Option Key)</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; padding: 10px; background-color: #f0f0f0; border-radius: 5px; width: 80%; max-width: 700px;}
        .controls label { display: block; margin-bottom: 5px; font-weight: bold; }
        .controls input[type="text"] { width: calc(100% - 22px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .controls textarea { width: calc(100% - 22px); min-height: 100px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
        .viewer-container {
            width: 70vw;
            max-width: 700px;
            height: 50vh;
            max-height: 500px;
            border: 1px solid #ccc;
            background-color: #e9e9e9;
            margin-bottom: 20px;
        }
        #instructions { margin-bottom:15px; padding:10px; background-color: #eef; border: 1px solid #ccf; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>IIIF Viewer - ROI Drawing Test (Alt/Option Key)</h1>

    <div id="instructions">
        <p>Hold <strong>Option</strong> (Mac) or <strong>Alt</strong> (Windows/Linux) key and then click and drag on the image to draw a rectangle. Release the mouse button to finalize the ROI. Pan and zoom are disabled while the modifier key is held.</p>
    </div>

    <div class="controls">
        <label for="urnInput">Base Image URN:</label>
        <input type="text" id="urnInput" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013">
        <button id="loadButton">Load Image</button>
    </div>

    <div id="imageViewer" class="viewer-container"></div>

    <div class="controls">
        <label for="drawnRois">Drawn ROIs (URN@x,y,w,h format):</label>
        <textarea id="drawnRois" readonly></textarea>
        <button id="clearRoisButton">Clear Drawn ROIs List</button>
    </div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInputElement = document.getElementById('urnInput');
            const loadButtonElement = document.getElementById('loadButton');
            const viewerContainerId = 'imageViewer';
            const drawnRoisTextarea = document.getElementById('drawnRois');
            const clearRoisButton = document.getElementById('clearRoisButton');

            function handleNewRoi(roiUrnString) {
                drawnRoisTextarea.value += roiUrnString + '\n';
            }

            function loadImageViewer() {
                const baseUrn = urnInputElement.value.trim();
                if (baseUrn) {
                    document.getElementById(viewerContainerId).innerHTML = 'Loading...';
                    HMTIIIFViewer.createViewer(viewerContainerId, baseUrn, handleNewRoi);
                } else {
                    document.getElementById(viewerContainerId).innerHTML = '<p style="color:red;">Please enter a base URN.</p>';
                }
            }

            loadButtonElement.addEventListener('click', loadImageViewer);
            clearRoisButton.addEventListener('click', () => {
                drawnRoisTextarea.value = '';
            });

            loadImageViewer();
        });
    </script>
</body>
</html>
```

These changes should now correctly map the draw mode to the Option/Alt key and prevent interference from default browser actions associated with that key.

### USER
This is excellent. Could we add a feature to display the user selected rectangles in exactly the same way as rectangles identifed with the ROI notation?  The rectangles should be drawn in a random color, and the opacity should be set to 0.5. Please update the code to reflect this change.

### ASSISTANT
Okay, this will make the drawing mode much more visually interactive! We'll have the viewer immediately display the user-drawn rectangles with random colors and the specified opacity.

Here's the plan:

1.  **Random Color Function**: Add a helper function `getRandomRgbaColor(opacity)` to generate a random `rgba()` string.
2.  **Update `mouseup` in Draw Mode**:
    *   When a rectangle is successfully drawn and its percentage coordinates (`roiPct`) are calculated:
        *   The external `onRoiDrawnCallback` will still be called as before.
        *   **Internally**:
            *   Convert `roiPct` back into absolute pixel coordinates on the original image (`newRoiOrigPx`).
            *   Generate a random color string with 0.5 opacity using the new helper.
            *   Create a new `div` element for this highlight, style it with the random color and `pointer-events: none`.
            *   Add this new highlight `div` to the `container`.
            *   Add an object `{ roiOrigPx: newRoiOrigPx, element: newHighlightDiv }` to the `roisData` array.
            *   Call `updateHighlightOverlays()` immediately. This will ensure the new rectangle is drawn correctly, respecting the current pan/zoom state.

This way, the drawn ROIs become part of the viewer's managed display items, behaving just like the ones loaded from URNs.

Here's the updated `hmt-iiif-viewer.js`:

**`hmt-iiif-viewer.js` (with immediate display of drawn ROIs)**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    const ROI_COLORS_PRESET = [ /* Renamed to avoid conflict */
        { r: 255, g: 0, b: 0 },    // Red
        { r: 0, g: 255, b: 0 },    // Green
        { r: 0, g: 0, b: 255 },    // Blue
        { r: 255, g: 255, b: 0 },  // Yellow
        { r: 255, g: 0, b: 255 },  // Magenta
        { r: 0, g: 255, b: 255 },  // Cyan
        { r: 255, g: 165, b: 0 },  // Orange
        { r: 128, g: 0, b: 128 },  // Purple
    ];
    const URN_ROI_OPACITY = 0.3; // Opacity for ROIs from URNs
    const DRAWN_ROI_OPACITY = 0.5; // Opacity for user-drawn ROIs

    function getRandomRgbaColor(opacity) {
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgba(${r},${g},${b},${opacity})`;
    }

    function parseCite2Urn(urnString) { /* ... as before ... */ 
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            // console.error("Invalid CITE2 URN format:", urnString);
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
            //  console.error("Invalid collection component in URN:", urnString);
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h };
                } else {
                    // console.warn("Invalid ROI values (must be 0-1, w/h > 0) in URN, ignoring ROI:", roiString);
                }
            } else {
                // console.warn("Invalid ROI component count in URN, ignoring ROI:", roiString);
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString,
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }
    function buildIIIFImageDataBase(parsedUrn) { /* ... as before ... */ 
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    function createViewer(elementId, urnInput, onRoiDrawnCallback) {
        const container = document.getElementById(elementId);
        // ... (Initial checks for container, urnInput, urnStringsArray setup as before)
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        let urnStringsArray;
        if (typeof urnInput === 'string') {
            urnStringsArray = [urnInput];
        } else if (Array.isArray(urnInput)) {
            urnStringsArray = urnInput;
        } else {
            container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
            return;
        }

        if (urnStringsArray.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${urnStringsArray[0]}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let roisData = []; // This will now hold all ROIs (from URNs and drawn)
        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;
        let currentScale = 1.0;
        let centerXOrig = 0, centerYOrig = 0;
        let isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        let isAltKeyDown = false;
        let isDrawingRectangle = false;
        let drawStartX = 0, drawStartY = 0;
        let tempDrawRectElement = null;
        let baseUrnForDrawing = '';

        const parsedUrns = urnStringsArray.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        // ... (Validation of parsedUrns, primaryParsedUrn, baseImageObjectId, iiifImageDataPath, infoUrl as before)
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        const primaryParsedUrn = parsedUrns[0];
        baseUrnForDrawing = `${primaryParsedUrn.urn.split('@')[0]}`;
        const baseImageObjectId = primaryParsedUrn.objectId;

        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images.</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;


        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                // Initialize ROIs from URNs
                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const colorObj = ROI_COLORS_PRESET[index % ROI_COLORS_PRESET.length];
                        const colorString = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, ${URN_ROI_OPACITY})`;
                        
                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => { /* ... */ });

        function scheduleRender() { /* ... */ 
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }
        function updateHighlightOverlays() { /* ... (no change needed here, it iterates roisData) ... */ 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) {
                 roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                 return;
            }
            // Ensure lastRequestedRegion is valid if we proceed with calculations based on it
             if (lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) {
                 // If no ROIs exist yet, or image not ready, hide all and return.
                 // This check is important if ROIs can be added before first renderImage.
                 roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                 return;
             }


            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }
        function renderImage() { /* ... as before ... */ 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays();
        }
        function constrainState() { /* ... as before ... */ 
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }
        function screenRectToImagePct(screenX, screenY, screenW, screenH) { /* ... as before ... */ 
            if (!imageInfo || lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) return null;

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            const x1_on_content_screen = screenX - contentOffsetX;
            const y1_on_content_screen = screenY - contentOffsetY;
            const x2_on_content_screen = screenX + screenW - contentOffsetX;
            const y2_on_content_screen = screenY + screenH - contentOffsetY;
            
            const x1_on_region_orig = x1_on_content_screen / serverScale;
            const y1_on_region_orig = y1_on_content_screen / serverScale;
            const x2_on_region_orig = x2_on_content_screen / serverScale;
            const y2_on_region_orig = y2_on_content_screen / serverScale;

            let roi_x_orig = finalReqX + x1_on_region_orig;
            let roi_y_orig = finalReqY + y1_on_region_orig;
            let roi_x2_orig = finalReqX + x2_on_region_orig;
            let roi_y2_orig = finalReqY + y2_on_region_orig;

            let roi_w_orig = Math.abs(roi_x2_orig - roi_x_orig);
            let roi_h_orig = Math.abs(roi_y2_orig - roi_y_orig);
            roi_x_orig = Math.min(roi_x_orig, roi_x2_orig);
            roi_y_orig = Math.min(roi_y_orig, roi_y2_orig);

            roi_x_orig = Math.max(0, Math.min(roi_x_orig, imageInfo.width));
            roi_y_orig = Math.max(0, Math.min(roi_y_orig, imageInfo.height));
            
            roi_w_orig = Math.min(roi_w_orig, imageInfo.width - roi_x_orig);
            roi_h_orig = Math.min(roi_h_orig, imageInfo.height - roi_y_orig);

            if (roi_w_orig <= 0 || roi_h_orig <= 0) return null;

            const pctX = roi_x_orig / imageInfo.width;
            const pctY = roi_y_orig / imageInfo.height;
            const pctW = roi_w_orig / imageInfo.width;
            const pctH = roi_h_orig / imageInfo.height;

            return {
                x: parseFloat(pctX.toFixed(4)),
                y: parseFloat(pctY.toFixed(4)),
                w: parseFloat(pctW.toFixed(4)),
                h: parseFloat(pctH.toFixed(4))
            };
        }

        function setupEventListeners() {
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Alt') {
                    event.preventDefault(); 
                    isAltKeyDown = true; 
                    if(!isDrawingRectangle) container.style.cursor = 'crosshair';
                }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Alt') {
                    isAltKeyDown = false; 
                    if(!isDrawingRectangle && !isDragging) container.style.cursor = 'grab';
                }
            });

            container.addEventListener('wheel', function(event) { /* ... as before ... */ 
                if (isAltKeyDown) { 
                    event.preventDefault(); 
                    return;
                }
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            container.addEventListener('mousedown', function(event) { /* ... as before ... */ 
                if (event.button !== 0) return;
                event.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isAltKeyDown) { 
                    isDrawingRectangle = true;
                    drawStartX = mouseXvp;
                    drawStartY = mouseYvp;

                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = document.createElement('div');
                    tempDrawRectElement.style.position = 'absolute';
                    tempDrawRectElement.style.border = '2px dashed blue'; // Temporary visual feedback
                    tempDrawRectElement.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    tempDrawRectElement.style.left = `${drawStartX}px`;
                    tempDrawRectElement.style.top = `${drawStartY}px`;
                    tempDrawRectElement.style.width = '0px';
                    tempDrawRectElement.style.height = '0px';
                    tempDrawRectElement.style.pointerEvents = 'none';
                    container.appendChild(tempDrawRectElement);
                    container.style.cursor = 'crosshair';
                } else {
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    container.style.cursor = 'grabbing';
                }
            });

            container.addEventListener('mousemove', function(event) { /* ... as before ... */ 
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isDrawingRectangle && isAltKeyDown) { 
                    if (tempDrawRectElement) {
                        const currentX = mouseXvp;
                        const currentY = mouseYvp;
                        const newX = Math.min(drawStartX, currentX);
                        const newY = Math.min(drawStartY, currentY);
                        const newW = Math.abs(drawStartX - currentX);
                        const newH = Math.abs(drawStartY - currentY);
                        tempDrawRectElement.style.left = `${newX}px`;
                        tempDrawRectElement.style.top = `${newY}px`;
                        tempDrawRectElement.style.width = `${newW}px`;
                        tempDrawRectElement.style.height = `${newH}px`;
                    }
                } else if (isDragging) {
                    const dx = event.clientX - lastMouseX;
                    const dy = event.clientY - lastMouseY;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;

                    centerXOrig -= dx / currentScale; 
                    centerYOrig -= dy / currentScale;
                    
                    constrainState();
                    scheduleRender();
                }
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;

                if (isDrawingRectangle && isAltKeyDown) {
                    if (tempDrawRectElement) {
                        const rect = tempDrawRectElement.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        const finalDrawX = rect.left - containerRect.left;
                        const finalDrawY = rect.top - containerRect.top;
                        const finalDrawW = rect.width;
                        const finalDrawH = rect.height;

                        tempDrawRectElement.remove(); // Remove temporary feedback rect
                        tempDrawRectElement = null;

                        if (finalDrawW > 2 && finalDrawH > 2 && imageInfo) { // Min size and ensure imageInfo is loaded
                            const roiPct = screenRectToImagePct(finalDrawX, finalDrawY, finalDrawW, finalDrawH);
                            if (roiPct) {
                                // External callback
                                if (typeof onRoiDrawnCallback === 'function') {
                                    const roiStringForCallback = `@${roiPct.x},${roiPct.y},${roiPct.w},${roiPct.h}`;
                                    onRoiDrawnCallback(baseUrnForDrawing + roiStringForCallback);
                                }

                                // Internal: Add to roisData for display
                                const newRoiOrigPx = {
                                    x: roiPct.x * imageInfo.width,
                                    y: roiPct.y * imageInfo.height,
                                    w: roiPct.w * imageInfo.width,
                                    h: roiPct.h * imageInfo.height
                                };
                                const randomColor = getRandomRgbaColor(DRAWN_ROI_OPACITY);
                                const newHighlightDiv = document.createElement('div');
                                newHighlightDiv.style.position = 'absolute';
                                newHighlightDiv.style.backgroundColor = randomColor;
                                newHighlightDiv.style.boxSizing = 'border-box';
                                newHighlightDiv.style.pointerEvents = 'none';
                                newHighlightDiv.style.display = 'none'; // Will be shown by updateHighlightOverlays
                                container.appendChild(newHighlightDiv);

                                roisData.push({
                                    roiOrigPx: newRoiOrigPx,
                                    element: newHighlightDiv
                                });
                                updateHighlightOverlays(); // Refresh display
                            }
                        }
                    }
                    isDrawingRectangle = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
                } else if (isDragging) {
                    isDragging = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
                }
            });

            container.addEventListener('mouseleave', function() { /* ... as before ... */ 
                if (isDrawingRectangle) { 
                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = null;
                    isDrawingRectangle = false;
                }
                if (isDragging) {
                    isDragging = false;
                }
                container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
            });
            
            container.style.cursor = 'grab';
            window.addEventListener('resize', function() { /* ... as before ... */ 
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        } 
    } 

    window.HMTIIIFViewer = {
        createViewer: createViewer
    };

})(window);
```

**Key Changes in `hmt-iiif-viewer.js`:**

1.  **`ROI_COLORS_PRESET`**: Renamed the original color array to avoid confusion.
2.  **`URN_ROI_OPACITY` and `DRAWN_ROI_OPACITY`**: Constants to define different opacities.
3.  **`getRandomRgbaColor(opacity)`**: New helper function.
4.  **Initializing URN ROIs**: In the `fetch.then(info => ...)` block, when creating highlight divs for URN-defined ROIs, it now uses `URN_ROI_OPACITY`.
5.  **`mouseup` Logic (Draw Mode)**:
    *   After `tempDrawRectElement.remove()`.
    *   If `roiPct` is valid and `imageInfo` is available:
        *   The external callback is called as before.
        *   **New Internal Handling**:
            *   `newRoiOrigPx` is calculated from `roiPct` and `imageInfo`.
            *   `randomColor` is generated using `getRandomRgbaColor(DRAWN_ROI_OPACITY)`.
            *   `newHighlightDiv` is created, styled with this color, and appended to the `container`.
            *   The new ROI (with `newRoiOrigPx` and `newHighlightDiv`) is pushed to `roisData`.
            *   `updateHighlightOverlays()` is called to immediately render this new highlight on the image.
6.  **A small robustness check in `updateHighlightOverlays`**: Made the condition for early exit a bit more robust, especially if `roisData` might be populated before `lastRequestedRegion` is fully valid (though less likely with current flow).

The `roi-draw-test.html` file does not need any changes for this feature, as the display of drawn ROIs is now handled internally by the viewer. When you draw a rectangle, it will call `handleNewRoi` (which updates the textarea) AND it will also draw the rectangle directly on the image.

### USER
Amazing! Let's add a new function. This function should accept a URN for an image, and return a string with the IIIF request for the image. The function should allow optional parameters to set an output width or height, but should ensure that aspect is maintained. If both width and height are set, the function should use the larger of the two to determine the scaling factor. If the URN includes an ROI extension, the function should use set the IIIF `pct:x,y,w,h` parameters the values in the extension scaled from 0 to 100. For example, if the URN is `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15`, the IIIF request should include `pct:25,50,40,15`. The function should also set the IIIF `size` parameter to the width and height of the image in pixels, scaled to the requested size. If no size is requested, the function should set the IIIF `size` parameter to `full`. The function should also set the IIIF `format` parameter to `jpg`.
The function should return a string with the full IIIF request for the image, including all parameters. Please write an HTML test page that allows a user to enter an image URN and optional values for width and height, displays the URN value on the page, and then displays the image retrieved with the IIIF request.

### ASSISTANT
Okay, this is a useful utility function to generate IIIF URLs directly from HMT URNs with more control over sizing and region.

Here's the plan:

1.  **New Function `generateIIIFUrl(urnString, options)` in `hmt-iiif-viewer.js`:**
    *   **`urnString`**: The CITE2 URN (can include `@roi`).
    *   **`options`** (optional object):
        *   `width`: Desired output width in pixels.
        *   `height`: Desired output height in pixels.
        *   If only `width` is given, scale to this width, height will adjust by aspect ratio.
        *   If only `height` is given, scale to this height, width will adjust by aspect ratio.
        *   If both `width` and `height` are given, the image will be scaled to *fit within* these dimensions, maintaining aspect ratio. This means one dimension will match, and the other will be less than or equal to the provided value. (This behavior is common for IIIF's `!w,h` syntax, which we'll use).
        *   If neither is given, `size` parameter will be `full`.
    *   **Parsing**: Uses `parseCite2Urn` to get components and ROI.
    *   **IIIF Base Path**: Uses `buildIIIFImageDataBase`.
    *   **Region Parameter**:
        *   If `parsedUrn.roi` exists, convert its 0-1 values to 0-100 percentages and format as `pct:x,y,w,h`.
        *   Else, region is `full`.
    *   **Size Parameter**:
        *   If `options.width` and/or `options.height` are provided:
            *   If only `width`: `w,` (e.g., `800,`)
            *   If only `height`: `,h` (e.g., `,600`)
            *   If both `width` and `height`: `!w,h` (e.g., `!800,600`)
        *   Else (no size options): `full`
    *   **Rotation Parameter**: `0` (default)
    *   **Quality/Format Parameter**: `default.jpg`
    *   **Return Value**: The complete IIIF URL string.

2.  **HTML Test Page (`iiif-url-generator.html`)**:
    *   Inputs for URN, optional width, optional height.
    *   A "Generate URL & Show Image" button.
    *   Displays the generated IIIF URL.
    *   Displays the image using the generated URL in an `<img>` tag.

Let's start with the JavaScript library update.

**`hmt-iiif-viewer.js` (with `generateIIIFUrl` function)**
```javascript
(function(window) {
    'use strict';

    const HMT_IIIF_PROTOCOL = "http";
    const HMT_IIIF_SERVER_BASE = "www.homermultitext.org/iipsrv?IIIF=";
    const HMT_IIIF_PATH_BASE = "/project/homer/pyramidal/deepzoom";

    const ROI_COLORS_PRESET = [ /* ... as before ... */ { r: 255, g: 0, b: 0 },{ r: 0, g: 255, b: 0 },{ r: 0, g: 0, b: 255 },{ r: 255, g: 255, b: 0 },{ r: 255, g: 0, b: 255 },{ r: 0, g: 255, b: 255 },{ r: 255, g: 165, b: 0 },{ r: 128, g: 0, b: 128 }];
    const URN_ROI_OPACITY = 0.3;
    const DRAWN_ROI_OPACITY = 0.5;

    function getRandomRgbaColor(opacity) { /* ... as before ... */ 
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgba(${r},${g},${b},${opacity})`;
    }

    function parseCite2Urn(urnString) { /* ... as before ... */ 
        if (typeof urnString !== 'string') return null;
        const parts = urnString.split(':');
        if (parts.length !== 5 || parts[0] !== 'urn' || parts[1] !== 'cite2') {
            return null;
        }
        const namespace = parts[2];
        const collectionVersion = parts[3].split('.');
        if (collectionVersion.length < 1) {
            return null;
        }
        const collection = collectionVersion[0];
        const version = collectionVersion.length > 1 ? collectionVersion[1] : '';
        
        const lastComponent = parts[4];
        const atSignIndex = lastComponent.indexOf('@');
        let objectId;
        let roi = null;

        if (atSignIndex !== -1) {
            objectId = lastComponent.substring(0, atSignIndex);
            const roiString = lastComponent.substring(atSignIndex + 1);
            const roiParts = roiString.split(',');
            if (roiParts.length === 4) {
                const [x, y, w, h] = roiParts.map(val => parseFloat(val));
                if ([x, y, w, h].every(n => !isNaN(n) && n >= 0 && n <= 1) && (w > 0) && (h > 0)) {
                    roi = { x, y, w, h }; // Store as 0-1 percentages
                }
            }
        } else {
            objectId = lastComponent;
        }

        return {
            urn: urnString,
            namespace: namespace,
            collection: collection,
            version: version,
            objectId: objectId,
            roi: roi
        };
    }
    function buildIIIFImageDataBase(parsedUrn) { /* ... as before ... */ 
        if (!parsedUrn) return null;
        let path = `${HMT_IIIF_PATH_BASE}/${parsedUrn.namespace}/${parsedUrn.collection}`;
        if (parsedUrn.version) {
            path += `/${parsedUrn.version}`;
        }
        path += `/${parsedUrn.objectId}.tif`;
        return path;
    }

    // NEW FUNCTION
    function generateIIIFUrl(urnString, options = {}) {
        const parsedUrn = parseCite2Urn(urnString);
        if (!parsedUrn) {
            console.error("Invalid URN for IIIF URL generation:", urnString);
            return null;
        }

        const iiifImageDataPath = buildIIIFImageDataBase(parsedUrn);
        if (!iiifImageDataPath) {
            console.error("Could not construct IIIF base path for URL generation:", urnString);
            return null;
        }

        let regionParameter = "full";
        if (parsedUrn.roi) {
            const x = parsedUrn.roi.x * 100;
            const y = parsedUrn.roi.y * 100;
            const w = parsedUrn.roi.w * 100;
            const h = parsedUrn.roi.h * 100;
            // IIIF spec suggests rounding or truncating, let's format to a few decimal places if needed, though integers are common for pct.
            // For simplicity and standard IIIF server behavior, integers are fine.
            regionParameter = `pct:${Math.round(x)},${Math.round(y)},${Math.round(w)},${Math.round(h)}`;
        }

        let sizeParameter = "full";
        const reqWidth = options.width ? parseInt(options.width, 10) : null;
        const reqHeight = options.height ? parseInt(options.height, 10) : null;

        if (reqWidth && reqHeight) {
            // Fit within dimensions, maintaining aspect ratio
            sizeParameter = `!${reqWidth},${reqHeight}`;
        } else if (reqWidth) {
            // Scale to width, height auto
            sizeParameter = `${reqWidth},`;
        } else if (reqHeight) {
            // Scale to height, width auto
            sizeParameter = `,${reqHeight}`;
        }
        // If neither, sizeParameter remains "full"

        const rotationParameter = "0";
        const qualityParameter = "default";
        const formatParameter = "jpg";

        return `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${regionParameter}/${sizeParameter}/${rotationParameter}/${qualityParameter}.${formatParameter}`;
    }


    function createViewer(elementId, urnInput, onRoiDrawnCallback) {
        // ... (createViewer function remains entirely the same as the previous version)
        const container = document.getElementById(elementId);
        if (!container) {
            console.error(`Element with ID '${elementId}' not found.`);
            return;
        }

        let urnStringsArray;
        if (typeof urnInput === 'string') {
            urnStringsArray = [urnInput];
        } else if (Array.isArray(urnInput)) {
            urnStringsArray = urnInput;
        } else {
            container.innerHTML = `<p style="color:red;">Invalid URN input: Must be a string or an array of strings.</p>`;
            return;
        }

        if (urnStringsArray.length === 0) {
            container.innerHTML = `<p style="color:red;">No URNs provided.</p>`;
            return;
        }

        container.innerHTML = '';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';

        const imgElement = document.createElement('img');
        imgElement.style.position = 'absolute';
        imgElement.style.top = '0';
        imgElement.style.left = '0';
        imgElement.draggable = false;
        imgElement.alt = `IIIF image for ${urnStringsArray[0]}`;
        container.appendChild(imgElement);
        
        const spinner = document.createElement('div');
        spinner.innerHTML = 'Loading...';
        spinner.style.position = 'absolute';
        spinner.style.top = '50%';
        spinner.style.left = '50%';
        spinner.style.transform = 'translate(-50%, -50%)';
        spinner.style.padding = '10px';
        spinner.style.background = 'rgba(255,255,255,0.8)';
        spinner.style.borderRadius = '5px';
        spinner.style.display = 'none';
        container.appendChild(spinner);

        let roisData = []; 
        let imageInfo = null;
        let viewportWidth = container.clientWidth;
        let viewportHeight = container.clientHeight;
        let currentScale = 1.0;
        let centerXOrig = 0, centerYOrig = 0;
        let isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let renderTimeout = null;
        const DEBOUNCE_DELAY = 150;
        let lastRequestedRegion = { x: 0, y: 0, w: 0, h: 0 };

        let isAltKeyDown = false;
        let isDrawingRectangle = false;
        let drawStartX = 0, drawStartY = 0;
        let tempDrawRectElement = null;
        let baseUrnForDrawing = '';

        const parsedUrns = urnStringsArray.map(urnStr => parseCite2Urn(urnStr)).filter(Boolean);
        if (parsedUrns.length === 0) {
            container.innerHTML = `<p style="color:red;">No valid URNs could be parsed.</p>`;
            return;
        }

        const primaryParsedUrn = parsedUrns[0];
        baseUrnForDrawing = `${primaryParsedUrn.urn.split('@')[0]}`;
        const baseImageObjectId = primaryParsedUrn.objectId;

        for (let i = 1; i < parsedUrns.length; i++) {
            if (parsedUrns[i].objectId !== baseImageObjectId ||
                parsedUrns[i].namespace !== primaryParsedUrn.namespace ||
                parsedUrns[i].collection !== primaryParsedUrn.collection ||
                parsedUrns[i].version !== primaryParsedUrn.version) {
                console.error("Mismatched base images in URN list.", parsedUrns[i], primaryParsedUrn);
                container.innerHTML = `<p style="color:red;">Error: URNs refer to different base images.</p>`;
                return;
            }
        }

        const iiifImageDataPath = buildIIIFImageDataBase(primaryParsedUrn);
        if (!iiifImageDataPath) {
             container.innerHTML = `<p style="color:red;">Could not construct IIIF path for: ${primaryParsedUrn.urn}</p>`;
            return;
        }
        const infoUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/info.json`;


        spinner.style.display = 'block';
        fetch(infoUrl, { mode: 'cors' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error ${response.status} fetching info.json`);
                return response.json();
            })
            .then(info => {
                imageInfo = { width: info.width, height: info.height };
                centerXOrig = imageInfo.width / 2;
                centerYOrig = imageInfo.height / 2;
                currentScale = Math.min(
                    viewportWidth / imageInfo.width,
                    viewportHeight / imageInfo.height
                );

                parsedUrns.forEach((pUrn, index) => {
                    if (pUrn.roi && imageInfo) {
                        const colorObj = ROI_COLORS_PRESET[index % ROI_COLORS_PRESET.length];
                        const colorString = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, ${URN_ROI_OPACITY})`;
                        
                        const highlightDiv = document.createElement('div');
                        highlightDiv.style.position = 'absolute';
                        highlightDiv.style.backgroundColor = colorString;
                        highlightDiv.style.boxSizing = 'border-box';
                        highlightDiv.style.pointerEvents = 'none';
                        highlightDiv.style.display = 'none';
                        container.appendChild(highlightDiv);

                        roisData.push({
                            roiOrigPx: {
                                x: pUrn.roi.x * imageInfo.width,
                                y: pUrn.roi.y * imageInfo.height,
                                w: pUrn.roi.w * imageInfo.width,
                                h: pUrn.roi.h * imageInfo.height
                            },
                            element: highlightDiv
                        });
                    }
                });

                constrainState();
                renderImage();
                setupEventListeners();
            })
            .catch(error => { 
                spinner.style.display = 'none';
                container.innerHTML = `<p style="color:red;">Error loading image info: ${error.message}</p>`;
                console.error("IIIF Load Error:", error);
            });

        function scheduleRender() { 
            spinner.style.display = 'block';
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderImage, DEBOUNCE_DELAY);
        }
        function updateHighlightOverlays() { 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) {
                 roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                 return;
            }
             if (lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) {
                 roisData.forEach(roiItem => { if(roiItem.element) roiItem.element.style.display = 'none';});
                 return;
             }


            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            roisData.forEach(roiItem => {
                const roiOrigPx = roiItem.roiOrigPx;
                const highlightElement = roiItem.element;

                const roiRelToRegionX_orig = roiOrigPx.x - finalReqX;
                const roiRelToRegionY_orig = roiOrigPx.y - finalReqY;
                const roiInContentX_screen = roiRelToRegionX_orig * serverScale;
                const roiInContentY_screen = roiRelToRegionY_orig * serverScale;
                const roiContentWidth_screen = roiOrigPx.w * serverScale;
                const roiContentHeight_screen = roiOrigPx.h * serverScale;

                const highlightDivX = contentOffsetX + roiInContentX_screen;
                const highlightDivY = contentOffsetY + roiInContentY_screen;
                const highlightDivW = roiContentWidth_screen;
                const highlightDivH = roiContentHeight_screen;
                
                if (highlightDivW < 1 || highlightDivH < 1 ||
                    highlightDivX + highlightDivW < 0 || highlightDivX > viewportWidth ||
                    highlightDivY + highlightDivH < 0 || highlightDivY > viewportHeight) {
                    highlightElement.style.display = 'none';
                } else {
                    highlightElement.style.left = `${Math.round(highlightDivX)}px`;
                    highlightElement.style.top = `${Math.round(highlightDivY)}px`;
                    highlightElement.style.width = `${Math.round(highlightDivW)}px`;
                    highlightElement.style.height = `${Math.round(highlightDivH)}px`;
                    highlightElement.style.display = 'block';
                }
            });
        }
        function renderImage() { 
            if (!imageInfo || viewportWidth === 0 || viewportHeight === 0) return;

            let reqWidthOrig = viewportWidth / currentScale;
            let reqHeightOrig = viewportHeight / currentScale;
            let reqXOrig = centerXOrig - reqWidthOrig / 2;
            let reqYOrig = centerYOrig - reqHeightOrig / 2;

            if (reqXOrig < 0) { reqXOrig = 0; }
            if (reqYOrig < 0) { reqYOrig = 0; }

            if (reqXOrig + reqWidthOrig > imageInfo.width) {
                reqWidthOrig = imageInfo.width - reqXOrig;
            }
            if (reqYOrig + reqHeightOrig > imageInfo.height) {
                reqHeightOrig = imageInfo.height - reqYOrig;
            }
            
            reqWidthOrig = Math.max(1, Math.round(reqWidthOrig));
            reqHeightOrig = Math.max(1, Math.round(reqHeightOrig));
            reqXOrig = Math.round(reqXOrig);
            reqYOrig = Math.round(reqYOrig);

            if (reqXOrig + reqWidthOrig > imageInfo.width) reqXOrig = imageInfo.width - reqWidthOrig;
            if (reqYOrig + reqHeightOrig > imageInfo.height) reqYOrig = imageInfo.height - reqHeightOrig;
            if (reqXOrig < 0) reqXOrig = 0;
            if (reqYOrig < 0) reqYOrig = 0;
            if (reqWidthOrig < 1) reqWidthOrig = 1;
            if (reqHeightOrig < 1) reqHeightOrig = 1;

            lastRequestedRegion = { x: reqXOrig, y: reqYOrig, w: reqWidthOrig, h: reqHeightOrig };

            const region = `${reqXOrig},${reqYOrig},${reqWidthOrig},${reqHeightOrig}`;
            const size = `!${viewportWidth},${viewportHeight}`;
            const imageUrl = `${HMT_IIIF_PROTOCOL}://${HMT_IIIF_SERVER_BASE}${iiifImageDataPath}/${region}/${size}/0/default.jpg`;
            
            imgElement.src = imageUrl;
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'contain';

            updateHighlightOverlays();
        }
        function constrainState() { 
            if (!imageInfo) return;
            const minFitScale = Math.min(viewportWidth / imageInfo.width, viewportHeight / imageInfo.height);
            currentScale = Math.max(minFitScale / 4, currentScale); 
            currentScale = Math.min(4, currentScale); 

            const effectiveDisplayWidthAtScale = imageInfo.width * currentScale;
            const effectiveDisplayHeightAtScale = imageInfo.height * currentScale;

            if (effectiveDisplayWidthAtScale <= viewportWidth) {
                centerXOrig = imageInfo.width / 2;
            } else {
                const minCenterX = (viewportWidth / 2) / currentScale;
                const maxCenterX = imageInfo.width - (viewportWidth / 2) / currentScale;
                centerXOrig = Math.max(minCenterX, Math.min(maxCenterX, centerXOrig));
            }

            if (effectiveDisplayHeightAtScale <= viewportHeight) {
                centerYOrig = imageInfo.height / 2;
            } else {
                const minCenterY = (viewportHeight / 2) / currentScale;
                const maxCenterY = imageInfo.height - (viewportHeight / 2) / currentScale;
                centerYOrig = Math.max(minCenterY, Math.min(maxCenterY, centerYOrig));
            }
        }
        function screenRectToImagePct(screenX, screenY, screenW, screenH) { 
            if (!imageInfo || lastRequestedRegion.w <= 0 || lastRequestedRegion.h <= 0) return null;

            const finalReqX = lastRequestedRegion.x;
            const finalReqY = lastRequestedRegion.y;
            const finalReqW = lastRequestedRegion.w;
            const finalReqH = lastRequestedRegion.h;
            const serverScale = Math.min(viewportWidth / finalReqW, viewportHeight / finalReqH);
            const renderedImageContentWidth = finalReqW * serverScale;
            const renderedImageContentHeight = finalReqH * serverScale;
            const contentOffsetX = (viewportWidth - renderedImageContentWidth) / 2;
            const contentOffsetY = (viewportHeight - renderedImageContentHeight) / 2;

            const x1_on_content_screen = screenX - contentOffsetX;
            const y1_on_content_screen = screenY - contentOffsetY;
            const x2_on_content_screen = screenX + screenW - contentOffsetX;
            const y2_on_content_screen = screenY + screenH - contentOffsetY;
            
            const x1_on_region_orig = x1_on_content_screen / serverScale;
            const y1_on_region_orig = y1_on_content_screen / serverScale;
            const x2_on_region_orig = x2_on_content_screen / serverScale;
            const y2_on_region_orig = y2_on_content_screen / serverScale;

            let roi_x_orig = finalReqX + x1_on_region_orig;
            let roi_y_orig = finalReqY + y1_on_region_orig;
            let roi_x2_orig = finalReqX + x2_on_region_orig;
            let roi_y2_orig = finalReqY + y2_on_region_orig;

            let roi_w_orig = Math.abs(roi_x2_orig - roi_x_orig);
            let roi_h_orig = Math.abs(roi_y2_orig - roi_y_orig);
            roi_x_orig = Math.min(roi_x_orig, roi_x2_orig);
            roi_y_orig = Math.min(roi_y_orig, roi_y2_orig);

            roi_x_orig = Math.max(0, Math.min(roi_x_orig, imageInfo.width));
            roi_y_orig = Math.max(0, Math.min(roi_y_orig, imageInfo.height));
            
            roi_w_orig = Math.min(roi_w_orig, imageInfo.width - roi_x_orig);
            roi_h_orig = Math.min(roi_h_orig, imageInfo.height - roi_y_orig);

            if (roi_w_orig <= 0 || roi_h_orig <= 0) return null;

            const pctX = roi_x_orig / imageInfo.width;
            const pctY = roi_y_orig / imageInfo.height;
            const pctW = roi_w_orig / imageInfo.width;
            const pctH = roi_h_orig / imageInfo.height;

            return {
                x: parseFloat(pctX.toFixed(4)),
                y: parseFloat(pctY.toFixed(4)),
                w: parseFloat(pctW.toFixed(4)),
                h: parseFloat(pctH.toFixed(4))
            };
        }

        function setupEventListeners() {
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Alt') {
                    event.preventDefault(); 
                    isAltKeyDown = true; 
                    if(!isDrawingRectangle) container.style.cursor = 'crosshair';
                }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === 'Alt') {
                    isAltKeyDown = false; 
                    if(!isDrawingRectangle && !isDragging) container.style.cursor = 'grab';
                }
            });

            container.addEventListener('wheel', function(event) { 
                if (isAltKeyDown) { 
                    event.preventDefault(); 
                    return;
                }
                event.preventDefault();
                const zoomFactor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;
                
                const idealViewOrigTopLeftX = centerXOrig - (viewportWidth / 2) / currentScale;
                const idealViewOrigTopLeftY = centerYOrig - (viewportHeight / 2) / currentScale;
                const ptXOrig = idealViewOrigTopLeftX + mouseXvp / currentScale;
                const ptYOrig = idealViewOrigTopLeftY + mouseYvp / currentScale;
                
                currentScale *= zoomFactor;
                constrainState(); 

                const newIdealViewOrigTopLeftX = ptXOrig - (mouseXvp / currentScale);
                const newIdealViewOrigTopLeftY = ptYOrig - (mouseYvp / currentScale);
                centerXOrig = newIdealViewOrigTopLeftX + (viewportWidth / 2) / currentScale;
                centerYOrig = newIdealViewOrigTopLeftY + (viewportHeight / 2) / currentScale;
                
                constrainState(); 
                scheduleRender();
            });

            container.addEventListener('mousedown', function(event) { 
                if (event.button !== 0) return;
                event.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isAltKeyDown) { 
                    isDrawingRectangle = true;
                    drawStartX = mouseXvp;
                    drawStartY = mouseYvp;

                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = document.createElement('div');
                    tempDrawRectElement.style.position = 'absolute';
                    tempDrawRectElement.style.border = '2px dashed blue'; 
                    tempDrawRectElement.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    tempDrawRectElement.style.left = `${drawStartX}px`;
                    tempDrawRectElement.style.top = `${drawStartY}px`;
                    tempDrawRectElement.style.width = '0px';
                    tempDrawRectElement.style.height = '0px';
                    tempDrawRectElement.style.pointerEvents = 'none';
                    container.appendChild(tempDrawRectElement);
                    container.style.cursor = 'crosshair';
                } else {
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    container.style.cursor = 'grabbing';
                }
            });

            container.addEventListener('mousemove', function(event) { 
                const rect = container.getBoundingClientRect();
                const mouseXvp = event.clientX - rect.left;
                const mouseYvp = event.clientY - rect.top;

                if (isDrawingRectangle && isAltKeyDown) { 
                    if (tempDrawRectElement) {
                        const currentX = mouseXvp;
                        const currentY = mouseYvp;
                        const newX = Math.min(drawStartX, currentX);
                        const newY = Math.min(drawStartY, currentY);
                        const newW = Math.abs(drawStartX - currentX);
                        const newH = Math.abs(drawStartY - currentY);
                        tempDrawRectElement.style.left = `${newX}px`;
                        tempDrawRectElement.style.top = `${newY}px`;
                        tempDrawRectElement.style.width = `${newW}px`;
                        tempDrawRectElement.style.height = `${newH}px`;
                    }
                } else if (isDragging) {
                    const dx = event.clientX - lastMouseX;
                    const dy = event.clientY - lastMouseY;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;

                    centerXOrig -= dx / currentScale; 
                    centerYOrig -= dy / currentScale;
                    
                    constrainState();
                    scheduleRender();
                }
            });

            container.addEventListener('mouseup', function(event) {
                if (event.button !== 0) return;

                if (isDrawingRectangle && isAltKeyDown) {
                    if (tempDrawRectElement) {
                        const rect = tempDrawRectElement.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        const finalDrawX = rect.left - containerRect.left;
                        const finalDrawY = rect.top - containerRect.top;
                        const finalDrawW = rect.width;
                        const finalDrawH = rect.height;

                        tempDrawRectElement.remove(); 
                        tempDrawRectElement = null;

                        if (finalDrawW > 2 && finalDrawH > 2 && imageInfo) { 
                            const roiPct = screenRectToImagePct(finalDrawX, finalDrawY, finalDrawW, finalDrawH);
                            if (roiPct) {
                                if (typeof onRoiDrawnCallback === 'function') {
                                    const roiStringForCallback = `@${roiPct.x},${roiPct.y},${roiPct.w},${roiPct.h}`;
                                    onRoiDrawnCallback(baseUrnForDrawing + roiStringForCallback);
                                }

                                const newRoiOrigPx = {
                                    x: roiPct.x * imageInfo.width,
                                    y: roiPct.y * imageInfo.height,
                                    w: roiPct.w * imageInfo.width,
                                    h: roiPct.h * imageInfo.height
                                };
                                const randomColor = getRandomRgbaColor(DRAWN_ROI_OPACITY);
                                const newHighlightDiv = document.createElement('div');
                                newHighlightDiv.style.position = 'absolute';
                                newHighlightDiv.style.backgroundColor = randomColor;
                                newHighlightDiv.style.boxSizing = 'border-box';
                                newHighlightDiv.style.pointerEvents = 'none';
                                newHighlightDiv.style.display = 'none'; 
                                container.appendChild(newHighlightDiv);

                                roisData.push({
                                    roiOrigPx: newRoiOrigPx,
                                    element: newHighlightDiv
                                });
                                updateHighlightOverlays(); 
                            }
                        }
                    }
                    isDrawingRectangle = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
                } else if (isDragging) {
                    isDragging = false;
                    container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
                }
            });

            container.addEventListener('mouseleave', function() { 
                if (isDrawingRectangle) { 
                    if (tempDrawRectElement) tempDrawRectElement.remove();
                    tempDrawRectElement = null;
                    isDrawingRectangle = false;
                }
                if (isDragging) {
                    isDragging = false;
                }
                container.style.cursor = isAltKeyDown ? 'crosshair' : 'grab';
            });
            
            container.style.cursor = 'grab';
            window.addEventListener('resize', function() { 
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    viewportWidth = container.clientWidth;
                    viewportHeight = container.clientHeight;
                    constrainState();
                    renderImage();
                }, DEBOUNCE_DELAY + 50);
            });
        } 
    } 


    // Expose public functions
    window.HMTIIIFViewer = {
        createViewer: createViewer,
        generateIIIFUrl: generateIIIFUrl // New function exposed
    };

})(window);
```

---

**`iiif-url-generator.html` (Test Page for the new function)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIIF URL Generator Test</title>
    <style>
        body { font-family: sans-serif; margin: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .input-group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; padding:15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9; width: 90%; max-width: 600px;}
        .input-group label { font-weight: bold; }
        .input-group input[type="text"], .input-group input[type="number"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        #outputArea { width: 90%; max-width: 600px; }
        #generatedUrl { word-break: break-all; background-color: #eee; padding: 10px; border-radius: 4px; margin-bottom: 10px; font-family: monospace; }
        #imageDisplay { border: 1px solid #ccc; max-width: 100%; max-height: 400px; object-fit: contain; } /* max-height for display */
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>IIIF URL Generator for HMT URNs</h1>

    <div class="input-group">
        <label for="urnInput">Image URN (can include @roi):</label>
        <input type="text" id="urnInput" value="urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15">

        <label for="widthInput">Desired Width (px, optional):</label>
        <input type="number" id="widthInput" placeholder="e.g., 800">

        <label for="heightInput">Desired Height (px, optional):</label>
        <input type="number" id="heightInput" placeholder="e.g., 600">

        <button id="generateBtn">Generate URL & Show Image</button>
    </div>

    <div id="outputArea">
        <h3>Generated IIIF URL:</h3>
        <div id="generatedUrl">(URL will appear here)</div>
        <h3>Image Preview:</h3>
        <img id="imageDisplay" src="" alt="Generated IIIF Image">
        <p id="errorMessage" class="error"></p>
    </div>

    <script src="hmt-iiif-viewer.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const urnInputElement = document.getElementById('urnInput');
            const widthInputElement = document.getElementById('widthInput');
            const heightInputElement = document.getElementById('heightInput');
            const generateBtnElement = document.getElementById('generateBtn');
            const generatedUrlElement = document.getElementById('generatedUrl');
            const imageDisplayElement = document.getElementById('imageDisplay');
            const errorMessageElement = document.getElementById('errorMessage');

            generateBtnElement.addEventListener('click', function() {
                const urn = urnInputElement.value.trim();
                const options = {};
                const widthVal = widthInputElement.value.trim();
                const heightVal = heightInputElement.value.trim();

                if (widthVal) options.width = parseInt(widthVal, 10);
                if (heightVal) options.height = parseInt(heightVal, 10);

                errorMessageElement.textContent = '';
                generatedUrlElement.textContent = '(Generating...)';
                imageDisplayElement.src = ''; // Clear previous image

                if (!urn) {
                    errorMessageElement.textContent = 'Please enter a URN.';
                    generatedUrlElement.textContent = '';
                    return;
                }

                const iiifUrl = HMTIIIFViewer.generateIIIFUrl(urn, options);

                if (iiifUrl) {
                    generatedUrlElement.textContent = iiifUrl;
                    imageDisplayElement.src = iiifUrl;
                    imageDisplayElement.alt = `Image for URN: ${urn}`;
                } else {
                    generatedUrlElement.textContent = '(Error generating URL)';
                    errorMessageElement.textContent = 'Could not generate IIIF URL. Check console for details and ensure URN is valid.';
                }
            });

            // Optionally, generate on page load with default values
            // generateBtnElement.click(); 
        });
    </script>
</body>
</html>
```

**Explanation of `generateIIIFUrl`:**

1.  **Parsing**: It uses the existing `parseCite2Urn` to break down the URN and extract any ROI.
2.  **Base Path**: `buildIIIFImageDataBase` constructs the image identifier part of the URL.
3.  **Region (`/region/`)**:
    *   If `parsedUrn.roi` (e.g., `{x: 0.25, y: 0.50, w: 0.40, h: 0.15 }`) is present, it's converted to percentages (e.g., `x: 25, y: 50, w: 40, h: 15`) and formatted as `pct:25,50,40,15`.
    *   Otherwise, it's `full`.
4.  **Size (`/size/`)**:
    *   `!w,h` (e.g., `!800,600`): If both width and height are provided. The image is scaled to fit *within* these dimensions while maintaining aspect ratio.
    *   `w,` (e.g., `800,`): If only width is provided. Scales to this width, height is automatic.
    *   `,h` (e.g., `,600`): If only height is provided. Scales to this height, width is automatic.
    *   `full`: If neither width nor height is provided.
5.  **Rotation (`/rotation/`)**: Hardcoded to `0`.
6.  **Quality & Format (`/quality.format`)**: Hardcoded to `default.jpg`.

The HTML test page allows users to input a URN (with or without `@roi`), optional width/height, and then see both the generated IIIF URL and the image itself fetched using that URL. This provides a good way to test the `generateIIIFUrl` function.

### USER
This is fantastic! I’m going to publish this library on github. Could you write API documentation for it in Markdown?

### ASSISTANT
Absolutely! Good API documentation is key for a useful library. Here's a Markdown version of the API documentation for `HMTIIIFViewer`.

```markdown
# HMT IIIF Viewer & Utilities API Documentation

This JavaScript library provides a lightweight, from-scratch IIIF image viewer tailored for Homer Multitext (HMT) CITE2 URNs, along with utility functions for generating IIIF URLs.

## Table of Contents

1.  [Installation](#installation)
2.  [Core Viewer: `HMTIIIFViewer.createViewer()`](#core-viewer-hmtiiifviewercreateviewer)
    *   [Parameters](#parameters)
    *   [Interactions](#interactions)
    *   [ROI Drawing Mode](#roi-drawing-mode)
    *   [Example Usage](#example-usage)
3.  [URL Generation: `HMTIIIFViewer.generateIIIFUrl()`](#url-generation-hmtiiifviewergenerateiiifurl)
    *   [Parameters](#parameters-1)
    *   [Return Value](#return-value)
    *   [Example Usage](#example-usage-1)
4.  [CITE2 URN Format for HMT Images](#cite2-urn-format-for-hmt-images)

## Installation

Include the `hmt-iiif-viewer.js` script in your HTML file:

```html
<script src="path/to/hmt-iiif-viewer.js"></script>
```

Or, if hosted on a CDN like jsDelivr (once you publish it to GitHub):

```html
<script src="https://cdn.jsdelivr.net/gh/YOUR_USERNAME/YOUR_REPONAME@VERSION/hmt-iiif-viewer.js"></script>
```

The library exposes a global object `HMTIIIFViewer`.

## Core Viewer: `HMTIIIFViewer.createViewer()`

This function creates an interactive IIIF image viewer instance within a specified DOM element. It supports panning, zooming, displaying multiple Regions of Interest (ROIs) defined in URNs, and a mode for users to draw new ROIs.

### Parameters

`HMTIIIFViewer.createViewer(elementId, urnInput, onRoiDrawnCallback)`

1.  **`elementId`** (String, Required)
    *   The `id` of the HTML `div` element where the viewer will be rendered. The viewer will clear any existing content within this element.

2.  **`urnInput`** (String | Array<String>, Required)
    *   A single CITE2 URN string or an array of CITE2 URN strings.
    *   All URNs (if an array is provided) **must** refer to the same base HMT image. They can differ by their ROI extension (e.g., `@x,y,w,h`).
    *   The first URN in the array (or the single URN if a string is passed) is used to fetch the base image information (`info.json`).
    *   ROIs specified in the URNs will be displayed as semi-opaque colored overlays on the image.
        *   Example single URN: `'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.2,0.2'`
        *   Example array of URNs:
            ```javascript
            [
                'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.2,0.2',
                'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.5,0.5,0.3,0.3'
            ]
            ```

3.  **`onRoiDrawnCallback`** (Function, Optional)
    *   A callback function that is invoked when a user successfully draws a new ROI on the image using the draw mode (see below).
    *   The callback receives one argument:
        *   `roiUrnString` (String): The base URN of the displayed image, appended with the newly drawn ROI in `@x,y,w,h` format (e.g., `'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15'`). Coordinates are percentages (0-1).
    *   User-drawn ROIs are also immediately displayed on the viewer with a random semi-opaque color.

### Interactions

*   **Pan**: Click and drag the image with the left mouse button.
*   **Zoom**: Use the mouse wheel. Zoom is centered on the mouse cursor's position.

### ROI Drawing Mode

*   **Activate**: Hold down the **Option** key (Mac) or **Alt** key (Windows/Linux). The cursor will change to a crosshair.
*   **Draw**: While the Option/Alt key is held, click and drag on the image to draw a rectangle. A temporary dashed blue rectangle will provide visual feedback.
*   **Finalize**: Release the mouse button.
    *   The `onRoiDrawnCallback` function (if provided) will be called with the URN string of the new ROI.
    *   The newly drawn ROI will be displayed on the image with a random color and 0.5 opacity.
*   **Cancel**: Move the mouse outside the viewer area while drawing, or release the Option/Alt key before releasing the mouse button (behavior might vary slightly, but releasing the mouse button is the primary finalization step).
*   **Disabled Interactions**: Panning and zooming are disabled while the Option/Alt key is held down.

### Example Usage

**HTML:**

```html
<div id="myViewer" style="width: 600px; height: 400px; border: 1px solid black;"></div>
<textarea id="drawnRoisOutput" rows="5" cols="70" readonly placeholder="Drawn ROIs will appear here..."></textarea>
```

**JavaScript:**

```javascript
function logDrawnRoi(roiUrn) {
    const outputArea = document.getElementById('drawnRoisOutput');
    outputArea.value += roiUrn + '\n';
    console.log("New ROI Drawn:", roiUrn);
}

// Single URN with an ROI
const urn1 = 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.2,0.2';
HMTIIIFViewer.createViewer('myViewer', urn1, logDrawnRoi);

// Multiple URNs for the same image, different ROIs (uncomment to use)
/*
const urns = [
    'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.1,0.1,0.2,0.2', // Reddish overlay
    'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.5,0.5,0.3,0.3'  // Greenish overlay
];
HMTIIIFViewer.createViewer('myViewer', urns, logDrawnRoi);
*/
```

## URL Generation: `HMTIIIFViewer.generateIIIFUrl()`

This utility function constructs a complete IIIF Image API URL string based on an HMT CITE2 URN and optional sizing parameters.

### Parameters

`HMTIIIFViewer.generateIIIFUrl(urnString, options)`

1.  **`urnString`** (String, Required)
    *   The HMT CITE2 URN for the image. It can optionally include an ROI extension (e.g., `@x,y,w,h`).

2.  **`options`** (Object, Optional)
    *   An object to specify desired output dimensions.
    *   **`options.width`** (Number, Optional): Desired output width in pixels.
    *   **`options.height`** (Number, Optional): Desired output height in pixels.
    *   **Sizing Behavior**:
        *   If only `width` is provided, the IIIF size parameter will be `w,` (e.g., `800,`).
        *   If only `height` is provided, the IIIF size parameter will be `,h` (e.g., `,600`).
        *   If both `width` and `height` are provided, the IIIF size parameter will be `!w,h` (e.g., `!800,600`), causing the image to be scaled to fit *within* these dimensions while maintaining its aspect ratio.
        *   If neither `width` nor `height` is provided (or the `options` object is omitted), the IIIF size parameter will be `full`.
    *   **ROI Behavior**:
        *   If the `urnString` includes an ROI extension (e.g., `...@0.25,0.50,0.40,0.15`), the IIIF region parameter will be set to `pct:x,y,w,h` with values scaled to 0-100 (e.g., `pct:25,50,40,15`).
        *   If no ROI extension is in the URN, the IIIF region parameter will be `full`.
    *   **Other IIIF Parameters**:
        *   Rotation is fixed at `0`.
        *   Quality is fixed at `default`.
        *   Format is fixed at `jpg`.

### Return Value

*   (String): The fully constructed IIIF URL.
*   (null): If the URN is invalid or the IIIF base path cannot be constructed. An error will also be logged to the console.

### Example Usage

```javascript
const urnWithRoi = 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15';
const urnWithoutRoi = 'urn:cite2:hmt:vaimg.2017a:VA012RN_0013';

// Example 1: ROI from URN, specific width
const url1 = HMTIIIFViewer.generateIIIFUrl(urnWithRoi, { width: 500 });
// Expected: .../pct:25,50,40,15/500,/0/default.jpg

// Example 2: No ROI in URN, fit within 300x300
const url2 = HMTIIIFViewer.generateIIIFUrl(urnWithoutRoi, { width: 300, height: 300 });
// Expected: .../full/!300,300/0/default.jpg

// Example 3: ROI from URN, full size
const url3 = HMTIIIFViewer.generateIIIFUrl(urnWithRoi);
// Expected: .../pct:25,50,40,15/full/0/default.jpg

// Example 4: No ROI, no specific size (full size)
const url4 = HMTIIIFViewer.generateIIIFUrl(urnWithoutRoi);
// Expected: .../full/full/0/default.jpg

console.log(url1);
document.getElementById('myImageElement').src = url2; // Display in an image tag
```

## CITE2 URN Format for HMT Images

HMT images are identified with CITE2 URNs which have 5 components separated by colons.

*   **Structure**: `urn:cite2:{namespace}:{collection_version}:{object_id}[@{roi}]`
*   **Example**: `urn:cite2:hmt:vaimg.2017a:VA012RN_0013`
    *   `namespace`: `hmt`
    *   `collection_version`: `vaimg.2017a` (parsed as collection `vaimg` and version `2017a`)
    *   `object_id`: `VA012RN_0013`
*   **Optional ROI Extension**:
    *   Appended to the `object_id` with an `@` symbol.
    *   Format: `@x,y,w,h` where `x, y, w, h` are comma-separated numbers representing percentages (0.0 to 1.0) of the image dimensions.
        *   `x`: horizontal offset of the top-left corner from the left edge.
        *   `y`: vertical offset of the top-left corner from the top edge.
        *   `w`: width of the region.
        *   `h`: height of the region.
    *   Example with ROI: `urn:cite2:hmt:vaimg.2017a:VA012RN_0013@0.25,0.50,0.40,0.15`
        *   This defines a rectangle starting at (25% X, 50% Y) with a width of 40% and a height of 15% of the total image dimensions.

This documentation should provide a clear guide for anyone looking to use your library!
```

You can save this as `API.md` or `README.md` in your GitHub repository. Consider adding a small animated GIF or static screenshots to the README showing the viewer in action, especially the ROI drawing feature, as that can greatly improve understanding.